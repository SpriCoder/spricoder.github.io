

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="SpriCoder">
  <meta name="keywords" content="">
  
    <meta name="description" content="2020-C++高级程序设计-C++ exam">
<meta property="og:type" content="article">
<meta property="og:title" content="2020-C++高级程序设计-C++ exam">
<meta property="og:url" content="https://spricoder.github.io/2020/07/01/2020-C-plus-plus-advanced-programming/2020-C-plus-plus-advanced-programming-C++%20exam/index.html">
<meta property="og:site_name" content="SpriCoder的博客">
<meta property="og:description" content="2020-C++高级程序设计-C++ exam">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/exam/2.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/exam/1.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/lec00/5.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/C++-OOP/img/11.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/C++-OOP/img/2.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/C++-OOP/img/5.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/C++-OOP/img/6.png">
<meta property="article:published_time" content="2020-07-01T11:31:00.000Z">
<meta property="article:modified_time" content="2022-03-07T10:37:00.501Z">
<meta property="article:author" content="SpriCoder">
<meta property="article:tag" content="考试">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/exam/2.png">
  
  
  <title>2020-C++高级程序设计-C++ exam - SpriCoder的博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.staticfile.org/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"spricoder.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"DYxfU2PHurs2yXd95Sq85bU2-gzGzoHsz","app_key":"YWKSJ5KaDC4GQh2F8JraQPBr","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>SpriCoder的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/website.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          <span id="subtitle" title="2020-C++高级程序设计-C++ exam">
            
          </span>
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-07-01 19:31" pubdate>
          2020年7月1日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          29k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          242 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">2020-C++高级程序设计-C++ exam</h1>
            
            <div class="markdown-body">
              
              <h2 id="c-exam"><a class="markdownIt-Anchor" href="#c-exam"></a> C++ Exam</h2>
<h1 id="1-空类c默认提供的方法"><a class="markdownIt-Anchor" href="#1-空类c默认提供的方法"></a> 1. 空类C++默认提供的方法</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//了解以下C++编译器默认提供的方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> &#123;&#125;; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> &#123;<br>    <span class="hljs-built_in">Empty</span>();<br>    <span class="hljs-built_in">Empty</span>(<span class="hljs-type">const</span> Empty&amp;);<br>    ~<span class="hljs-built_in">Empty</span>();<br>    Empty&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Empty&amp;);<br>    Empty *<span class="hljs-keyword">operator</span> &amp;();<br>    <span class="hljs-type">const</span> Empty* <span class="hljs-keyword">operator</span> &amp;() <span class="hljs-type">const</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="2-智能指针"><a class="markdownIt-Anchor" href="#2-智能指针"></a> 2. 智能指针</h1>
<ol>
<li>通过将一些需要的信息进行封装的方法，来保证不管出现什么异常，在退出相应操作部分时，自动调用对象的析构函数来保证不会出现内存泄漏的问题。</li>
<li>同样的还有句柄类(C++ 异常中有)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">auto_ptr</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">auto_ptr</span>(T *p=<span class="hljs-number">0</span>):<span class="hljs-built_in">ptr</span>(p) &#123;&#125;<br>        ~<span class="hljs-built_in">auto_ptr</span>() &#123; <span class="hljs-keyword">delete</span> ptr; &#125;<br>        T* <span class="hljs-keyword">operator</span>-&gt;()  <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ptr;&#125;<br>	    T&amp; <span class="hljs-keyword">operator</span> *()  <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *ptr; &#125;<br>    <span class="hljs-keyword">private</span>:<br>        T*  ptr;<br>&#125;;<br><span class="hljs-comment">//结合智慧指针使用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processAdoptions</span><span class="hljs-params">(istream&amp; dataSource)</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (dataSource)&#123;<br>        <span class="hljs-function">auto_ptr&lt;ALA&gt; <span class="hljs-title">pa</span><span class="hljs-params">(readALA(dataSource))</span></span>;<br>        pa-&gt;<span class="hljs-built_in">processAdoption</span>();<span class="hljs-comment">//只要对象结束，就会自动delete</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="3-指针"><a class="markdownIt-Anchor" href="#3-指针"></a> 3. 指针</h1>
<h2 id="31-指针和内存处理"><a class="markdownIt-Anchor" href="#31-指针和内存处理"></a> 3.1. 指针和内存处理</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//将从pointer开始的长度为size的内存全部清空</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">memset</span> <span class="hljs-params">(<span class="hljs-type">void</span> *pointer, <span class="hljs-type">unsigned</span> size)</span> </span>&#123;<br>    <span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span> *)pointer;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;size;k++)&#123;<br>      *p++ = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//将src位置上和后面size长度的数据拷贝到des的位置上去</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *des, <span class="hljs-type">void</span> *src, <span class="hljs-type">unsigned</span> size)</span> </span>&#123;<br>	<span class="hljs-type">char</span> *sp = (<span class="hljs-type">char</span> *)src;<br>	<span class="hljs-type">char</span> *dp = (<span class="hljs-type">char</span> *)des;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>		*dp++ = *sp++;<br>	&#125;<br>&#125;<br><span class="hljs-comment">//查看从q开始的长度为nbit的数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showBytes</span><span class="hljs-params">(<span class="hljs-type">void</span> *q, <span class="hljs-type">int</span> n)</span><span class="hljs-comment">//查看内存</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; n &lt;&lt; endl;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)q;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>    cout &lt;&lt; (<span class="hljs-type">void</span> *)(p+i) &lt;&lt; <span class="hljs-string">&quot; : &quot;</span>&lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>) &lt;&lt; hex &lt;&lt; (<span class="hljs-type">int</span>)*(p+i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>	  <span class="hljs-keyword">if</span> ( (i+<span class="hljs-number">1</span>) %<span class="hljs-number">4</span> ==<span class="hljs-number">0</span> ) cout &lt;&lt; endl;<br>	&#125;<br>	cout &lt;&lt; dec &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="32-函数指针"><a class="markdownIt-Anchor" href="#32-函数指针"></a> 3.2. 函数指针</h2>
<ol>
<li>函数指针可以使得我们类似传递参数一样传递函数指针。</li>
<li>函数指针允许我们抽象一些操作，同时支持我们实现多态操作。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数指针的定义，这个函数指针是参数为int的，返回值为double的函数指针。</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">double</span> <span class="hljs-params">(*FP)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> *<span class="hljs-title">fp</span> <span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    FP fp;<br>    fp = f;   <span class="hljs-comment">//相当于fp = &amp;f;为函数指针赋值</span><br>    (*fp)(<span class="hljs-number">10</span>);<span class="hljs-comment">//相当于fp(10);</span><br>    fp = g;  <span class="hljs-comment">//Error</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="33-c中的lambda表达式"><a class="markdownIt-Anchor" href="#33-c中的lambda表达式"></a> 3.3. C++中的Lambda表达式</h2>
<ol>
<li>语法:<code>[capture](parameters) mutable -&gt;return-type&#123;statement&#125;</code>
<ol>
<li>capture：捕获列表</li>
<li>parameters：参数列表</li>
<li>-&gt;mutable：修饰符，可以取消lambda函数使其不是const函数，使用时参数列表不可省略(就算为空)</li>
<li>return type:返回类型</li>
<li>statement:函数体，可以使用参数和捕获变量</li>
</ol>
</li>
<li>例子:<code>auto func = [=, &amp;b](int c)-&gt;int &#123;return b += a + c;&#125;;</code></li>
</ol>
<h2 id="34-指针和数组"><a class="markdownIt-Anchor" href="#34-指针和数组"></a> 3.4. 指针和数组</h2>
<h3 id="341-一维数组"><a class="markdownIt-Anchor" href="#341-一维数组"></a> 3.4.1. 一维数组</h3>
<ol>
<li><code>int *p = a</code>,a代表数组的首地址。</li>
<li><code>*(p+i)</code>:p的位置不移动。</li>
<li><code>*(p++)</code>:p向前移动一个位置。</li>
<li><code>sizeof(a)</code>:数组的大小。</li>
<li><code>sizeof(a[0])</code>:数组的元素的占地大小。</li>
<li>几个等价操作:
<ol>
<li><code>a[i] == *(a+i)</code></li>
<li><code>&amp;a[i] == a+i</code></li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> &#125;;<br><span class="hljs-type">int</span> *p = &amp;a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>	cout &lt;&lt; *p++ &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">//指针移动</span><br>    <span class="hljs-comment">//等价于 cout &lt;&lt; *(p++) &lt;&lt; &quot; &quot;</span><br>    <span class="hljs-comment">//不等价于 cout &lt;&lt; (*p)++ &lt;&lt; &quot; &quot;,这样指针不移动</span><br>	cout &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>	cout &lt;&lt; *(p + i) &lt;&lt; endl;<span class="hljs-comment">//指针不动</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>		cout &lt;&lt; a[j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br>	cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>上面代码的结果如下，上图中为什么等价，是因为<ins>的优先级高于*，<a href = "https://blog.csdn.net/lfb_2048/article/details/62040608?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-62040608.nonecase&utm_term=c++%20%E4%B8%AD*%E5%92%8C/%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7">C</ins>的优先级和结合性</a></p>
</blockquote>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/exam/2.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<h3 id="342-二维数组"><a class="markdownIt-Anchor" href="#342-二维数组"></a> 3.4.2. 二维数组</h3>
<ol>
<li>有一些操作相对于其组成部分(一维数组越界了，但是对于其本身没有越界)，也就是C++对于这一类越界是默许的，因为这块系统空间在我们的控制中。</li>
<li><code>int *p = &amp;a[0][0]</code>:访问二维数组中的T类型的变量</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> b[<span class="hljs-number">20</span>][<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> *q;<br>q = &amp;b[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<span class="hljs-comment">//等价于 q = b[0]</span><br><span class="hljs-comment">//b[i][j] == *(&amp;b[0][0] + i*10 + j) == *(q + i * 10 + j) == q[i*10 + j]</span><br>T *p;<br>p = &amp;b[<span class="hljs-number">0</span>];<span class="hljs-comment">// p = b</span><br></code></pre></td></tr></table></figure>
<h3 id="343-降维操作"><a class="markdownIt-Anchor" href="#343-降维操作"></a> 3.4.3. 降维操作</h3>
<blockquote>
<p>使用线性方式来访问二维数组</p>
</blockquote>
<h3 id="344-升维操作"><a class="markdownIt-Anchor" href="#344-升维操作"></a> 3.4.4. 升维操作</h3>
<blockquote>
<p>对于一维数组，建立逻辑视图，按照多维数组的方式进行访问，可以在传递参数的时候直接进行划分。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],  <span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)  &#123;<br>        cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">int</span> a[][<span class="hljs-number">2</span>], <span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;j++) &#123;<br>            cout &lt;&lt; a[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            cout &lt;&lt; *(a+i)+j &lt;&lt; <span class="hljs-string">&quot; :&quot;</span> &lt;&lt; a[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-comment">//四个换一行</span><br>            <span class="hljs-keyword">if</span> ((i*<span class="hljs-number">2</span>+j+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span> == <span class="hljs-number">0</span>)<br>                cout &lt;&lt; endl;<br>        &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">int</span> a[][<span class="hljs-number">2</span>][<span class="hljs-number">3</span>], <span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;j++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;k++)&#123;<br>                cout &lt;&lt; a[i][j][k] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>                cout &lt;&lt; *(*(a+i)+j)+k &lt;&lt; <span class="hljs-string">&quot; :&quot;</span> &lt;&lt; a[i][j][k] &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>                <span class="hljs-comment">//换行输出</span><br>                <span class="hljs-keyword">if</span> ((i*<span class="hljs-number">6</span>+j*<span class="hljs-number">3</span>+k+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span> == <span class="hljs-number">0</span>)<br>                    cout &lt;&lt; endl;<br>            &#125;<br>	cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> b[<span class="hljs-number">12</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">12</span>;i++)  b[i] = i+<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">show</span>(b,<span class="hljs-number">12</span>);<br>    <span class="hljs-comment">//二维数组</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> T[<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">show</span>((T*)b,<span class="hljs-number">6</span>);<span class="hljs-comment">//show((int (*)[2])b,6),一定有括号</span><br><br>    <span class="hljs-comment">//三维数组</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> T1[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">typedef</span> T1 T2[<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">show</span>((T2*)b,<span class="hljs-number">2</span>);<span class="hljs-comment">//show((int (*)[2][3])b,2)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>结果如下图</p>
</blockquote>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/exam/1.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<h2 id="35-指针数组"><a class="markdownIt-Anchor" href="#35-指针数组"></a> 3.5. 指针数组</h2>
<ol>
<li>main函数:<code>int main(int argc,char * argv[],char * env[])</code>
<ul>
<li>argc:参数个数(包含命令)</li>
<li>argv:命令行参数</li>
<li>env:环境参数(为什么这个不必指出长度?因为\0结束，一个结束符)</li>
</ul>
</li>
<li>可变参数(详见C++指针与引用)：主要是利用内存机制，实现print函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyPrint</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, ...)</span></span>&#123;<br>    va_list marker;<span class="hljs-comment">//拿到一个指针,这个指针是字符串开始的位置</span><br>    <span class="hljs-built_in">va_start</span>(marker,s);<span class="hljs-comment">//找到参数的位置，s的位置</span><br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">while</span> ((c=s[i]) != <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27;%&#x27;</span>)<br>            cout &lt;&lt; c;<br>        <span class="hljs-keyword">else</span>&#123;<br>            i++;<br>            <span class="hljs-keyword">switch</span> (c=s[i])&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;f&#x27;</span>: cout &lt;&lt; <span class="hljs-built_in">va_arg</span>(marker,<span class="hljs-type">double</span>); <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>: cout &lt;&lt; <span class="hljs-built_in">va_arg</span>(marker,<span class="hljs-type">int</span>);<span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>: cout &lt;&lt; <span class="hljs-built_in">va_arg</span>(marker,<span class="hljs-type">char</span>);<span class="hljs-keyword">break</span>;<br>		    &#125;<br>	    &#125;<br>   	    i++;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-built_in">va_end</span>(marker);<span class="hljs-comment">//将当前指针回归原始状态          </span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">MyPrint</span>(<span class="hljs-string">&quot;double: %f integer: %d string: %c &quot;</span>,<span class="hljs-number">1.1</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;A&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="36-指针的拷贝和地址传递"><a class="markdownIt-Anchor" href="#36-指针的拷贝和地址传递"></a> 3.6. 指针的拷贝和地址传递</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//传递引用，影响原来的值。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myswap</span><span class="hljs-params">(<span class="hljs-type">int</span> *p1, <span class="hljs-type">int</span> *p2)</span> </span>&#123;<br>	<span class="hljs-type">int</span>* tmp = p1;<br>	p1 = p2;<br>	p2 = tmp;<br>&#125;<br><span class="hljs-comment">//传递参数，拷贝进入函数体，不影响原来的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myswap2</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p1, <span class="hljs-type">int</span> &amp; p2)</span> </span>&#123;<br>	<span class="hljs-type">int</span> tmp = p1;<br>	p1 = p2;<br>	p2 = tmp;<br>&#125;<br><span class="hljs-comment">//传递引用，影响原来的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myswap</span><span class="hljs-params">(<span class="hljs-type">char</span> **p1, <span class="hljs-type">char</span> **p2)</span> </span>&#123;<br>	<span class="hljs-type">char</span> *tmp = *p1;<br>	*p1 = *p2;<br>	*p2 = tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">char</span> *p1 =(<span class="hljs-type">char</span>*) <span class="hljs-string">&quot;abcd&quot;</span>;<br>	<span class="hljs-type">char</span> *p2 =(<span class="hljs-type">char</span>*) <span class="hljs-string">&quot;1234&quot;</span>;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">100</span>;<br>	<span class="hljs-type">int</span> b = <span class="hljs-number">200</span>;<br>	<span class="hljs-built_in">myswap</span>(&amp;a, &amp;b);<br>	cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="hljs-comment">//100 200</span><br>	<span class="hljs-built_in">myswap2</span>(a, b);<br>	cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="hljs-comment">//200 100</span><br>	<span class="hljs-built_in">myswap</span>(&amp;p1, &amp;p2);<br>	cout &lt;&lt; p1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; endl;<span class="hljs-comment">//1234 abcd</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="4-动态变量"><a class="markdownIt-Anchor" href="#4-动态变量"></a> 4. 动态变量</h1>
<ol>
<li>程序员在Heap上主动申请空间进行存储。</li>
</ol>
<h2 id="41-申请动态变量"><a class="markdownIt-Anchor" href="#41-申请动态变量"></a> 4.1. 申请动态变量</h2>
<ol>
<li>申请动态变量:申请的过程可能会失败
<ol>
<li>new:<code>new &lt;类型名&gt; [&lt;整型表达式&gt;]</code>。首先分配对应大小的内存，然后调用构造函数进行初始化，最后再赋值给对应的值。</li>
<li>malloc:<code>int *p = (int *)malloc(sizeof(int));</code>，不推荐，只是分配了空间，但是并不会调用构造函数。</li>
<li>为什么引入new和delete？因为新的操作符可以解决初始化函数的析构函数的调用的问题</li>
</ol>
</li>
<li>分配连续空间:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//使用malloc进行空间分配</span><br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)*<span class="hljs-number">10</span>)<br><span class="hljs-built_in">int</span> (*p2)[<span class="hljs-number">5</span>] = (<span class="hljs-built_in">int</span> (*)[<span class="hljs-number">5</span>])p;<br><span class="hljs-comment">//new，如下是new的错误写法</span><br>q = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">5</span>];<br><span class="hljs-comment">//new，多维数组</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ROWS = <span class="hljs-number">3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> COLUMNS = <span class="hljs-number">4</span>;<br><span class="hljs-type">char</span> **chArray2;<br><span class="hljs-comment">//首先分配好行的位置</span><br>chArray2 = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>* [ROWS];<br><span class="hljs-comment">//然后对每一行分配对应的数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> row = <span class="hljs-number">0</span>; row &lt; ROWS; row++ )<br>    chArray2[row] = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[ COLUMNS ];<br><span class="hljs-comment">//删除算法和新建算法完全一样</span><br></code></pre></td></tr></table></figure>
<h2 id="42-分配空间的初始化问题"><a class="markdownIt-Anchor" href="#42-分配空间的初始化问题"></a> 4.2. 分配空间的初始化问题</h2>
<ol>
<li><code>int *p1 = new int[5];</code> 默认不进行初始化</li>
<li><code>int *p2 = new int[5]();</code>进行默认初始化</li>
<li><code>int *p2 = new int[5]&#123;0,1,2,3,4&#125;</code>:进行显式对应函数初始化</li>
</ol>
<h2 id="43-释放动态变量"><a class="markdownIt-Anchor" href="#43-释放动态变量"></a> 4.3. 释放动态变量</h2>
<ol>
<li>释放动态变量:
<ol>
<li><code>new - delete | delete[]</code>:使用new的方式创建的动态变量，通过delete的方式释放
<ol>
<li><code>delete a</code>:释放数组的第一个元素</li>
<li><code>delete[] a</code>:释放数组中的所有的元素，注意此时归还是从a开始向下归还size大小的空间，所以a必须是数组的首地址才行。</li>
<li>delete会调用变量的析构函数，注意删除原对象之后要将对应的指针置为NULL，避免悬挂指针</li>
</ol>
</li>
<li><code>malloc free</code>:只是释放对应的申请的空间，但不会调用析构函数</li>
<li>归还操作前，注意要拷贝一个指针值，不然无法找到归还开始的头部地址。</li>
</ol>
</li>
</ol>
<h2 id="44-动态变量的应用单链表和多链表"><a class="markdownIt-Anchor" href="#44-动态变量的应用单链表和多链表"></a> 4.4. 动态变量的应用：单链表和多链表</h2>
<ol>
<li>单链表和双链表要求掌握</li>
<li>注意指针的移动情况</li>
</ol>
<h1 id="5-引用"><a class="markdownIt-Anchor" href="#5-引用"></a> 5. 引用</h1>
<ol>
<li>定义：为一块已有的内存空间取一个别名，定义引用变量的时候必须同时声明</li>
<li>可以通过函数副作用，来使得返回值也可以是引用和函数指针。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//一旦是p的别名，就一定只能是p的别名了</span><br><span class="hljs-type">int</span> &amp;a = *p;<br><span class="hljs-comment">//利用函数副作用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span>;<br></code></pre></td></tr></table></figure>
<ol start="3">
<li>可以使用const修饰引用，避免造成不必要的修改</li>
</ol>
<h1 id="6-c语言特性"><a class="markdownIt-Anchor" href="#6-c语言特性"></a> 6. C++语言特性</h1>
<ol>
<li>C++是强类型语言、动/静结合、类型安全不能代替测试。
<ol>
<li>弱类型允许隐式转换</li>
<li>动：编译时决定类型，静：编译前决定类型。</li>
</ol>
</li>
<li>注解:对于char、int、float、double(四种基本数据类型)和修饰符(long、short、signed、unsigned):
<ol>
<li>char只可以被signed和unsigned修饰</li>
<li>float不能被修饰</li>
<li>double只能用long修饰</li>
<li>int可以被四种修饰符组合修饰</li>
</ol>
</li>
<li>sizeof：返回字节为单位的对应单位的大小。</li>
<li>typedef：可以有效地提高系统的可移植性。</li>
<li>枚举常量：直接输出枚举常量，会在屏幕上显示对应的值，而不是枚举的名称，不能直接给枚举类赋一个int值，可以today = weekday(4),其中weekday是预定义好的枚举类。</li>
</ol>
<h1 id="7-关键字注解"><a class="markdownIt-Anchor" href="#7-关键字注解"></a> 7. 关键字注解</h1>
<ol>
<li>this关键字：可以用来访问自己的地址。</li>
<li>static:
<ol>
<li>全局有效：函数释放后也不会释放自身空间。</li>
<li>static的成员函数，需要在声明的时候进行修饰，但是没有this指针</li>
</ol>
</li>
<li>const对象在对应声明周期中是常量</li>
</ol>
<h1 id="8-运算符"><a class="markdownIt-Anchor" href="#8-运算符"></a> 8. 运算符</h1>
<ol>
<li>自增量运算符</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>	<span class="hljs-type">int</span> b, c, d, e;<br>	cout &lt;&lt; a &lt;&lt; endl;<span class="hljs-comment">//1 a = 1</span><br>	b = a++;<br>	cout &lt;&lt; b &lt;&lt; endl;<span class="hljs-comment">//1 b = 1 a = 2</span><br>	c = a--;<br>	cout &lt;&lt; c &lt;&lt; endl;<span class="hljs-comment">//2 c = 2 a = 1</span><br>	d = ++a;<br>	cout &lt;&lt; d &lt;&lt; endl;<span class="hljs-comment">//2 d = 2 a = 2</span><br>	e = --a;<br>	cout &lt;&lt; e &lt;&lt; endl;<span class="hljs-comment">//1 e = 1 a = 1</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>条件运算符:<code>&lt;exp1&gt;?&lt;exp2&gt;:&lt;exp3&gt;</code>
<ol>
<li>唯一的三目运算符,不允许进行<strong>重载</strong></li>
<li>如果<code>&lt;exp2&gt;</code>和<code>&lt;exp3&gt;</code>的值类型相同且均为左值，则该条件运算符表达式为左值表达式。</li>
<li>可以嵌套(满足就近原则)</li>
</ol>
</li>
<li>逗号表达式:按照顺序，连续进行运算,格式形如：<code>&lt;exp1&gt;,&lt;exp2&gt;,...,&lt;expn&gt;</code>,<code>&lt;expn&gt;</code>的值是逗号表达式的值,如<code>&lt;exp n&gt;</code>为左值，则该逗号表达式为左值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a,b,c;<br>d = (a = <span class="hljs-number">1</span>,b = a + <span class="hljs-number">2</span>,c = b + <span class="hljs-number">3</span>)<br><span class="hljs-comment">//a = 1</span><br><span class="hljs-comment">//b = 3</span><br><span class="hljs-comment">//c = d = 6</span><br></code></pre></td></tr></table></figure>
<ol start="4">
<li>异或操作
<ol>
<li>与全0的二进制串进行运算：不变</li>
<li>与全1的二进制串进行运算：取反</li>
<li>与本身的运算：清零</li>
<li>与同一个对象进行异或运算两次：还原，应用:进行加密</li>
</ol>
</li>
<li>交换x和y</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//允许中间变量</span><br><span class="hljs-type">int</span> t = x;<br>x = y;<br>y = t<br><span class="hljs-comment">//不允许中间变量</span><br>a = a ^ b<br>b = b ^ a<br>a = a ^ b<br><span class="hljs-comment">//或者</span><br>x = x + y<br>y = x - y<br>x = x - y<br></code></pre></td></tr></table></figure>
<ol start="6">
<li>左值表达式和右值表达式
<ol>
<li>左值表达式:<code>++i</code></li>
<li>右值表达式:<code>i++</code></li>
</ol>
</li>
</ol>
<h1 id="9-c历史"><a class="markdownIt-Anchor" href="#9-c历史"></a> 9. C++历史</h1>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/lec00/5.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<ol>
<li>目的:更告诉地进行编码</li>
<li>John Backus:发明了FORTRAN，使得编程更贴近于问题本身</li>
<li>Dijkstra:发明了编译器，著名观点:goto是有害的，不能随意跳转</li>
<li>Algol 60:其中阐述了很多的一些观点</li>
<li>脉络一:Algol 68:结构化编程的部分的继承
<ul>
<li>Niklaus Wirth:发明了PASCAL，很实用于教学</li>
<li>C. A. R. Hoare</li>
<li>Donald E.Knuth:和 Dijkstra一同提出goto有害性</li>
<li>继承下来:关于结构化编程的特性</li>
</ul>
</li>
<li>脉络二:系统化编程的继承
<ul>
<li>BCPL:贴近计算机，写出高效的程序，很好的想法:将IO作为类成分而不是语言成分，以提高语言可移植性</li>
<li>在BCPL和C之间还有B语言，B语言是将BCPL里面的比较繁杂的部分取出。</li>
<li>C:Dennis Ritchie、Ken Thompson，compiler决定程序语义和性质</li>
<li>继承下来:关于系统编程的特性</li>
</ul>
</li>
<li>脉络三:Simula 67 第一个OO的研究(OO部分的继承)
<ul>
<li>OO的第一个提出人:Ole-Johan Dahl、Kristen Nygaard</li>
<li>继承下来:关于面向对象编程的特性</li>
<li>Barbara Liskov:关于高层复用做出很大的贡献</li>
</ul>
</li>
<li>C++为什么不叫D:因为并没有完全抛弃C中的很多东西，粗略说法</li>
<li>C++的编译过程:
<ol>
<li>C++源代码想通过cpp预处理后再通过Cfront翻译成C语言，最后通过C编译器来使程序运行。</li>
<li>用Cfront不用Cpre的原因：Cpre不懂C语法，Cfront懂，发现语法错误会传回source code，但Cpre将方言部分翻译成c后交给cc，此时若发现错误才传回source code</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>名词</th>
<th>全称</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>cpre</td>
<td>-</td>
<td>将C++扩展内容翻译成为c</td>
<td>是C With Class中的含有的</td>
</tr>
<tr>
<td>cfront</td>
<td>-</td>
<td>将c++翻译成为c,可以直接检查语法错误，而不必经过cc</td>
<td>编译简单分成前端后端，前端负责语法检查，后端负责代码生成和优化，cc负责后端</td>
</tr>
<tr>
<td>cc</td>
<td>c compiler</td>
<td>c编译器，负责进行语法检查，有问题返回Source code</td>
<td>-</td>
</tr>
<tr>
<td>cpp</td>
<td>c pre process</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<h1 id="10-oop-面向对象编程"><a class="markdownIt-Anchor" href="#10-oop-面向对象编程"></a> 10. OOP 面向对象编程</h1>
<ol>
<li>对象类型的判断:
<ol>
<li>运行时判断</li>
<li>编译时判断</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//运行时判断</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">typeid</span>(i) == <span class="hljs-built_in">typeid</span>(<span class="hljs-type">int</span>) )<br>    cout &lt;&lt; <span class="hljs-string">&quot;i is int&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//编译时判断</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T t )</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;i is not int&quot;</span> &lt;&lt; endl ;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-type">void</span> <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span> i)&#123;<span class="hljs-comment">//特化</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;i is int&quot;</span> &lt;&lt; endl ;<br>&#125;<br><span class="hljs-type">int</span> i;<br><span class="hljs-built_in">func</span>(i)<br></code></pre></td></tr></table></figure>
<h2 id="101-操作系统中的变量地址分配情况"><a class="markdownIt-Anchor" href="#101-操作系统中的变量地址分配情况"></a> 10.1. 操作系统中的变量地址分配情况</h2>
<ol>
<li>栈空间:局部变量、值传递参数</li>
<li>堆空间:动态内存分配的位置</li>
</ol>
<h2 id="102-友元"><a class="markdownIt-Anchor" href="#102-友元"></a> 10.2. 友元</h2>
<ol>
<li>友元是数据保护和访问效率的折衷方案，可以访问private和protected的成员</li>
</ol>
<h3 id="1021-友元函数"><a class="markdownIt-Anchor" href="#1021-友元函数"></a> 10.2.1. 友元函数</h3>
<ol>
<li>一个全局函数是一个友元函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-type">int</span> j;<br>	<span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(A a)</span></span>;<span class="hljs-comment">//友元函数</span><br>&#125;;<br><span class="hljs-comment">//全局函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(A a)</span></span><br><span class="hljs-function"></span>&#123;<br>   cout &lt;&lt; a.j &lt;&lt;endl;<span class="hljs-comment">//因为func是A的友元，所以可以访问A的所有成员变量</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1022-友元类"><a class="markdownIt-Anchor" href="#1022-友元类"></a> 10.2.2. 友元类</h3>
<ol>
<li>友元类：一个类是另一个类的友元</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<span class="hljs-comment">//编译器会寻找一个类B来完成友元，如果没有会默认创建一个</span><br><span class="hljs-keyword">friend</span> B;<span class="hljs-comment">//多用于模板类，不引入B\</span><br><span class="hljs-comment"></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>	<span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;    <span class="hljs-comment">//友元类:B中的每一个函数都可以访问A的成员函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="1023-友元类成员函数"><a class="markdownIt-Anchor" href="#1023-友元类成员函数"></a> 10.2.3. 友元类成员函数</h3>
<ol>
<li>在完整的类的声明完成之前是不能够被声明的。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">C::f</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//友元类成员函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="1024-友元函数的声明"><a class="markdownIt-Anchor" href="#1024-友元函数的声明"></a> 10.2.4. 友元函数的声明</h3>
<ol>
<li>友元函数在之前可以没有声明</li>
<li>友元函数如果之前还没有声明过，则当做已经声明了</li>
<li>但是友元类函数在完整的类声明出现前不能声明友元函数。</li>
<li>为什么友元函数和友元类成员函数的声明要求是不一样的？
<ol>
<li>数据的一致性:避免对应类里面没有这个函数(也就是C的完整定义必须有)</li>
<li>成员函数依赖于类</li>
</ol>
</li>
</ol>
<h3 id="1025-友元函数注意"><a class="markdownIt-Anchor" href="#1025-友元函数注意"></a> 10.2.5. 友元函数注意</h3>
<ol>
<li>友元函数不具有传递性</li>
<li>友元必须显示声明</li>
<li>互为友元的两个类声明时是否需要<strong>前置声明</strong>
<ol>
<li>如果A和B不在一个命名空间不能通过编译</li>
<li>如果A和B在一个命名空间的话可以没有前置声明</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">vector</span>;<span class="hljs-comment">//必须有这个才能完成编译，不然找到Vector的类声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span>&#123;<br> 	<span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">multiply</span><span class="hljs-params">(Matrix &amp;m, Vector &amp;v, Vector &amp;r)</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>&#123;<br> 	<span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">multiply</span><span class="hljs-params">(Matrix &amp;m, Vector &amp;v, Vector &amp;r)</span></span>;<br>&#125;;<br><br><span class="hljs-comment">//类成员函数的声明顺序</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(B &amp;b)</span></span>&#123;<br>        std::cout &lt;&lt; b.b;<span class="hljs-comment">//这里可以吗？不行，不知道B中有b</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(A &amp;a)</span></span>&#123;<br>            std::cout &lt;&lt; a.a;<span class="hljs-comment">//这里是可以的</span><br>        &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">A::show</span> <span class="hljs-params">(B &amp;b)</span></span>&#123;<span class="hljs-comment">//只能在这里面实现</span><br>    std::cout &lt;&lt; b.b;<br>&#125;<br><br><span class="hljs-comment">//类和protected</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br>    <span class="hljs-keyword">protected</span> :<br>        <span class="hljs-type">int</span> prot_mem;<span class="hljs-comment">// protected 成员</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sneaky</span> : <span class="hljs-keyword">public</span> Base &#123;<span class="hljs-comment">//36min</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Sneaky&amp;)</span></span>;<span class="hljs-comment">//能访问Sneaky::prot_mem </span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Base&amp;)</span></span>;<span class="hljs-comment">//不能访问Base::prot_mem，对外不可见</span><br>    <span class="hljs-type">int</span> j;<span class="hljs-comment">// j 默认是private </span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Sneaky &amp;s)</span> </span>&#123;<br>        s.j = s.prot_mem = <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-comment">//正确：clobber 能访问Sneaky对象的 private和protected成员 </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Base &amp;b)</span> </span>&#123;<br>        b.prot_mem = <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-comment">//错误:clobber 不能访问Base的 protected 成员</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="103-多态"><a class="markdownIt-Anchor" href="#103-多态"></a> 10.3. 多态</h2>
<ol>
<li>函数重载:(静态多态)，和虚函数的动态多态不同(一名多用):函数重载包含操作符重载</li>
<li>类属多态:模板:template</li>
</ol>
<h3 id="1031-函数重载"><a class="markdownIt-Anchor" href="#1031-函数重载"></a> 10.3.1. 函数重载</h3>
<ol>
<li>函数重载要求名同、参数不同，而返回值的类型不能进行区分。</li>
<li>歧义转换
<ol>
<li>按照顺序匹配</li>
<li>找到最佳匹配
<ol>
<li>原则一:这个匹配每一个参数不必其他的匹配更差</li>
<li>原则二:这个匹配有一个参数更精确匹配</li>
</ol>
</li>
</ol>
</li>
<li>重载是为了让事情有效率，而不是过分有效率</li>
</ol>
<h3 id="1032-单目操作符重载"><a class="markdownIt-Anchor" href="#1032-单目操作符重载"></a> 10.3.2. 单目操作符重载</h3>
<ol>
<li>自增自减运算符的重载</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Counter</span>() &#123; value = <span class="hljs-number">0</span>; &#125;<br>        Counter&amp; <span class="hljs-keyword">operator</span> ++()<span class="hljs-comment">//++a 左值</span><br>        &#123;<br>            value ++;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        Counter <span class="hljs-keyword">operator</span> ++(<span class="hljs-type">int</span>)<span class="hljs-comment">//a++ 右值，int是dummy argument 哑元变量</span><br>        &#123;<br>            Counter temp = *<span class="hljs-keyword">this</span>;<br>            value++;<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li><code>&lt;&lt;</code>的重载:<code>ostream&amp; operator &lt;&lt; (ostream&amp; o, Day&amp; d)</code>，返回引用保证可以链式调用,如果没有&amp;，那么在第一个return出现了对象拷贝，容易出现临时变量不能返回拷贝的问题</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (ostream&amp; o, Day&amp; d)<br>&#123;	<span class="hljs-keyword">switch</span> (d)<br>	&#123;	<span class="hljs-keyword">case</span> SUN: o &lt;&lt; <span class="hljs-string">&quot;SUN&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;<span class="hljs-comment">//直接使用ostream中的&lt;&lt;</span><br>		<span class="hljs-keyword">case</span> MON: o &lt;&lt; <span class="hljs-string">&quot;MON&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> TUE: o &lt;&lt; <span class="hljs-string">&quot;TUE&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> WED: o &lt;&lt; <span class="hljs-string">&quot;WED&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> THU: o &lt;&lt; <span class="hljs-string">&quot;THU&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> FRI: o &lt;&lt; <span class="hljs-string">&quot;FRI&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> SAT: o &lt;&lt; <span class="hljs-string">&quot;SAT&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> o;<span class="hljs-comment">//为什么要return ostream类型的变量:需要连续的使用可以链式调用，Cout &lt;&lt; 1 &lt;&lt; 2;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="3">
<li><code>=</code>的重载：<code>A&amp; operator = (A&amp; a)</code>不可以被继承，返回引用对象。在<code>=</code>复制的过程中，尽可能地避免出现自我复制的情况(可以在程序入口检查)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">int</span> x,y ;<br>    <span class="hljs-type">char</span> *p ;<br>    <span class="hljs-keyword">public</span> :<br>        A&amp; <span class="hljs-keyword">operator</span> = (A&amp; a) &#123;<br>            <span class="hljs-comment">//赋值</span><br>            x = a.x;<br>            y = a.y;<br>            <span class="hljs-keyword">delete</span> []p;<br>            p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(a.p)+<span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">strcpy</span>(p,a.p);<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//也会出现悬指针</span><br>        &#125;<span class="hljs-comment">//还有问题，就是赋值自身会出现问题</span><br>&#125;;<br>A a, b;<br>a = b;<span class="hljs-comment">//调用自己的复制</span><br><br><span class="hljs-comment">//idle pointer，B被析构的时候会将p释放掉，导致p指向已经被释放掉的指针</span><br><span class="hljs-comment">//Memory leak,A申请的区域可能没有办法被释放</span><br><br><span class="hljs-comment">//更安全的拷贝，先new再delete</span><br><span class="hljs-type">char</span> *pOrig = p;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span> ...<br><span class="hljs-built_in">strcpy</span>();<br><span class="hljs-keyword">delete</span> pOrig;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br><span class="hljs-comment">//自我复制问题</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;a)<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br></code></pre></td></tr></table></figure>
<ol start="4">
<li><code>[]</code>操作符的重载:<code>char&amp; operator[](int i)</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span> &#123;<br>    <span class="hljs-type">char</span> *p;<br>    <span class="hljs-keyword">public</span> :<br>        <span class="hljs-built_in">string</span>(<span class="hljs-type">char</span> *p1)&#123;<br>            p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span> [<span class="hljs-built_in">strlen</span>(p1)+ <span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">strcpy</span>(p,p1);<span class="hljs-comment">//#pragma warning(disable:4996)来屏蔽问题</span><br>        &#125;<br>        <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i)&#123;<br>            <span class="hljs-keyword">return</span> p[i];<br>        &#125;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>&#123;<br>            <span class="hljs-keyword">return</span> p[i];<br>        &#125;<br>        <span class="hljs-comment">//可以用两个重载函数吗?是可以的</span><br>        <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">string</span>() &#123; <span class="hljs-keyword">delete</span>[] p ; &#125;<br>&#125;;<br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;aacd&quot;</span>)</span></span>;<br>s[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;b&#x27;</span> ;<br><span class="hljs-comment">//第一个重载加上const可以使得const或者非const对象都可以调用</span><br><span class="hljs-function"><span class="hljs-type">const</span> string <span class="hljs-title">cs</span><span class="hljs-params">(<span class="hljs-string">&#x27;const&#x27;</span>)</span></span>;<br>cout &lt;&lt; cs[<span class="hljs-number">0</span>];<br><span class="hljs-type">const</span> cs[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;D&#x27;</span>;<span class="hljs-comment">//const 版本不想被赋值(返回const的)，非const版本想要被赋值，之后再进行重载的时候就需要同时重载两个</span><br></code></pre></td></tr></table></figure>
<ol start="5">
<li><code>()</code>操作符的重载:
<ol>
<li>类型转换:<code>operator double()</code></li>
<li>函数调用:<code>double operator()(double,int,int)</code></li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类型转换</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br>    <span class="hljs-keyword">public</span>: <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2) &#123;<br>        n = n1;<br>        d = n2;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//类型转换操作符，语法特殊</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)n/d;<br>    &#125;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> n, d;<br>&#125;;<br><br><span class="hljs-comment">//函数调用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Func</span> &#123;<br>    <span class="hljs-type">double</span> para;<br>    <span class="hljs-type">int</span> lowerBound , upperBound ;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">double</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span></span>;<br>&#125;;<br>Func f;<br><span class="hljs-built_in">f</span>(<span class="hljs-number">2.4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure>
<h3 id="1033-不支持重载的操作符"><a class="markdownIt-Anchor" href="#1033-不支持重载的操作符"></a> 10.3.3. 不支持重载的操作符</h3>
<ol>
<li>不可以重载的操作符:<code>.</code>(成员访问操作符)、<code>.*</code>(成员指针访问运算符，如下)、<code>::</code>(域操作符)、<code>?:</code>(条件操作符)、<code>sizeof</code>:也不重载
<ol>
<li>原因:前两个为了防止类访问出现混乱</li>
<li>::后面是名称不是变量</li>
<li>?:条件运算符涉及到跳转，如果重载就影响了理解</li>
</ol>
</li>
<li>不建议重载的操作符号:永远不要重载<code>&amp;&amp;</code>和<code>||</code>会造成极大的问题</li>
</ol>
<h3 id="1034-全局函数重载操作符号"><a class="markdownIt-Anchor" href="#1034-全局函数重载操作符号"></a> 10.3.4. 全局函数重载操作符号</h3>
<ol>
<li>友元:<code>friend &lt;ret type&gt; operator #(&lt;arg1&gt;,&lt;arg2&gt;)</code></li>
<li>格式:<code>&lt;ret type&gt; operator #(&lt;arg1&gt;,&lt;arg2&gt;)</code></li>
<li>注意:<code>=</code>、<code>()</code>、<code>[]</code>、<code>-&gt;</code>不可以作为全局函数重载
<ol>
<li>单目运算符最好重载为类的成员函数</li>
<li>双目运算符最好重载为类的友元函数</li>
</ol>
</li>
<li>问题:为什么禁止在类外禁止重载赋值操作符?
<ol>
<li>如果没有类内提供一个赋值操作符，则编译器会默认提供一个类内的复制操作符</li>
<li>查找操作符优先查找类内，之后查找全局，所以全局重载赋值操作符不可能被用到</li>
</ol>
</li>
</ol>
<h3 id="1035-双目操作符重载"><a class="markdownIt-Anchor" href="#1035-双目操作符重载"></a> 10.3.5. 双目操作符重载</h3>
<ol>
<li>格式:<code>&lt;ret type&gt;operator #(&lt;arg&gt;)</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">name</span>&gt; a,b;<br>a <span class="hljs-meta"># b;<span class="hljs-comment">//a -&gt; this</span></span><br>a.<span class="hljs-keyword">operator</span>#(b)<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>加法重载:<code>friend Complex operator+(Complex&amp; c1 , Complex&amp; c2);</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Complex <span class="hljs-keyword">operator</span>+ (Complex&amp; c1 , Complex&amp; c2 ) &#123;<span class="hljs-comment">//全局函数重载至少包含一个用户自定义类型</span><br>    Complex temp;<br>    temp.real = c1.real + c2.real;<br>    temp.imag = c1.imag + c2.imag;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<span class="hljs-comment">//一般返回临时变量</span><br></code></pre></td></tr></table></figure>
<ol start="3">
<li>加减乘除:返回拷贝，不是引用，效率不太高?为了解决这个问题:可以返回值优化，第一个return没有拷贝，直接返回的是一个对象(无拷贝)，先计算，最后生成一个对象返回。</li>
<li><code>-&gt;</code>为二元运算符，重载的时候按照一元操作符重载描述。<code>A*operator-&gt;()</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//包裹被操作的资源，在意外退出的条件下，自动删除原来的资源</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AWrapper</span>&#123;<span class="hljs-comment">//不包含逻辑</span><br>    A* p;<span class="hljs-comment">// ? T p; 支持多个类型</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">AWrapper</span>(A *p) &#123; <span class="hljs-keyword">this</span>-&gt;p = p;&#125;<br>        ~<span class="hljs-built_in">AWrapper</span>() &#123; <span class="hljs-keyword">delete</span> p;&#125;<br>        A*<span class="hljs-keyword">operator</span>-&gt;() &#123; <span class="hljs-keyword">return</span> p;&#125;<span class="hljs-comment">//32min重新听一下</span><br>&#125;;<span class="hljs-comment">//RAII 资源获取及初始化</span><br><span class="hljs-comment">//函数返回，销毁局部指针的时候会直接删除</span><br></code></pre></td></tr></table></figure>
<h3 id="1036-结合操作符重载的多维数组结果"><a class="markdownIt-Anchor" href="#1036-结合操作符重载的多维数组结果"></a> 10.3.6. 结合操作符重载的多维数组结果</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array2D</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> *p;<br>        <span class="hljs-type">int</span> num1, num2;<br>    <span class="hljs-keyword">public</span>:<br>	    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Array1D</span>&#123;<span class="hljs-comment">//Surrogate 多维，proxy class</span><br>            <span class="hljs-keyword">public</span>:<br>                <span class="hljs-built_in">Array1D</span>(<span class="hljs-type">int</span> *p) &#123; <span class="hljs-keyword">this</span>-&gt;p = p; &#125;<br>                <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[ ] (<span class="hljs-type">int</span> index) &#123; <span class="hljs-keyword">return</span> p[index]; &#125;<br>                <span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>[ ] (<span class="hljs-type">int</span> index) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> p[index]; &#125;<br>	        <span class="hljs-keyword">private</span>:<br>		        <span class="hljs-type">int</span> *p;<br>        &#125;;<br>        <span class="hljs-built_in">Array2D</span>(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2) &#123;<br>            p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n1 * n2];<br>            num1 = n1;<br>            num2 = n2;<br>        &#125;<br>        <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Array2D</span>() &#123;<br>            <span class="hljs-keyword">delete</span> [] p;<br>        &#125;<br>        Array1D <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) &#123;<br>            <span class="hljs-keyword">return</span> p + index * num2;<span class="hljs-comment">//return的值和int*相同，构造函数不能声明成显式构造函数。</span><br>        &#125;<br>        <span class="hljs-comment">//这里为什么是array1D?通过构造函数进行类型转换</span><br>        <span class="hljs-type">const</span> Array1D <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> index) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> p+index*num2;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="1037-重载new和delete操作符"><a class="markdownIt-Anchor" href="#1037-重载new和delete操作符"></a> 10.3.7. 重载new和delete操作符</h3>
<blockquote>
<p>new的部分</p>
</blockquote>
<ol>
<li>方法:
<ol>
<li>调用系统存储分配，申请一块较大的内存</li>
<li>针对该内存，自己管理存储分配、去配</li>
<li>通过重载new与delete来实现</li>
<li>重载的new与delete是静态成员(隐式的，不需要额外声明，不允许操作任何类的数据成员)</li>
<li>重载的new与delete遵循类的访问控制，可继承(注意派生类和继承类的大小问题，开始5min左右)</li>
</ol>
</li>
<li>有些我们重复新建销毁的，比如Restful的可以单独管理</li>
<li>可以重载成全局函数，也可以重载成类成员函数，支持定向处理(如下面例子)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(size != <span class="hljs-built_in">sizeof</span>(base))<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span> (size);<span class="hljs-comment">//调用全局标准库的new进行size的分配，标准库的new永远是可以使用的</span><br><span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>;<br><span class="hljs-keyword">new</span> A[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span> [];<br><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span>*)</span><span class="hljs-comment">//是不可以被重载的，标准库版本</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> size, ostream &amp; log)</span></span>;<span class="hljs-comment">//可以同时写入到日志</span><br><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span> * pointer)</span></span>;<span class="hljs-comment">//定位new，placement new，被调用的时候，在指针给定的地方的进行new(可能预先已经分配好的)，分配比较快，长时间运行不被打断(不会导致内存不足)</span><br><br><span class="hljs-comment">//也可以new的时候指定自定义地址</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;&#125;;<br><span class="hljs-type">char</span> buf[<span class="hljs-built_in">sizeof</span>(A)];<br>A* a = <span class="hljs-built_in">new</span>(buf) A;<span class="hljs-comment">//定位new，不用分配内存，直接使用buf指向的区域</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>delete的部分</p>
</blockquote>
<ol>
<li><code>void operator delete(void *,size_t size)</code></li>
<li>名：operator delete</li>
<li>返回类型:void</li>
<li>第一个参数:void *(必须)：被撤销对象的地址</li>
<li>第二个参数:可有可无;如果有，则必须为size_t类型：被撤销对象的大小</li>
<li>delete 的重载只能有一个</li>
<li>如果重载了delete，那么通过 delete 撤消对象时将不再调用内置的(预定义的)delete</li>
<li>动态删除其父类的所有的。</li>
<li>如果子类中有一个虚继承函数，则size_t大小会根据继承情况进行确定大小</li>
</ol>
<h2 id="104-模板"><a class="markdownIt-Anchor" href="#104-模板"></a> 10.4. 模板</h2>
<ol>
<li>模板是一种代码复用机制，模板定义多个类的时候需要显式实例化，如果用不到的化，则不会实例化模板。</li>
<li>模板是不同于重复耦合和函数重载的一种更高效的解决方案</li>
<li>函数模板的实例化:
<ol>
<li><strong>隐式实现</strong></li>
<li>根据具体模板函数调用</li>
</ol>
</li>
<li>函数模板的参数
<ol>
<li>可有多个类型参数，用逗号分隔:<code>template &lt;class T1, class T2&gt;</code></li>
<li>可带普通参数:
<ul>
<li><strong>必须列在类型参数之后</strong>:<code>template &lt;class T, int size&gt;</code></li>
<li>调用时需显式实例化，使用默认参数值可以不显式实例化</li>
</ul>
</li>
<li>类型参数和普通参数都可以给出默认参数，但是必须从右侧向左侧给出</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T1 a, T2 b)</span> </span>&#123;&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> size&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T a)</span> </span>&#123;T temp[size];&#125;<br><span class="hljs-built_in">f</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-number">10</span>&gt;(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
<h3 id="1041-类属函数"><a class="markdownIt-Anchor" href="#1041-类属函数"></a> 10.4.1. 类属函数</h3>
<ol>
<li>使用宏解决:<code>#define max(a,b) ((a)&gt;(b)?(a):(b))</code>,只有简单功能，没有类型检查</li>
</ol>
<h3 id="1042-函数模板"><a class="markdownIt-Anchor" href="#1042-函数模板"></a> 10.4.2. 函数模板</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//int和double都可以使用，编译器编译的并不是之下的代码，而是T转化成具体代码，然后分别编译</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T A[], <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;num; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt; num - i; j++) &#123;<br>            <span class="hljs-keyword">if</span>  (A[j] &gt; A[j+<span class="hljs-number">1</span>]) &#123;<br>                T t = A[j];<br>                A[j] = A[j+<span class="hljs-number">1</span>];<br>                A[j+<span class="hljs-number">1</span>] = t;<br>            &#125;<br>        &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;...&#125;<br>C a[<span class="hljs-number">300</span>];<br><span class="hljs-built_in">sort</span>(a, <span class="hljs-number">300</span>);<span class="hljs-comment">//没有重载操作符&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="1043-类属模板"><a class="markdownIt-Anchor" href="#1043-类属模板"></a> 10.4.3. 类属模板</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类属模板需要显式实例化</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br>    T buffer[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">( T x)</span></span>;<br>        <span class="hljs-function">T <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> Stack &lt;T&gt; ::<span class="hljs-built_in">push</span>(T x) &#123;...&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T Stack &lt;T&gt; ::<span class="hljs-built_in">pop</span>() &#123;...&#125;<br><br><span class="hljs-comment">//如下是显式实例化</span><br>Stack &lt;<span class="hljs-type">int</span>&gt; st1;<br>Stack &lt;<span class="hljs-type">double</span>&gt; st2;<br></code></pre></td></tr></table></figure>
<h3 id="1044-模板给出的位置"><a class="markdownIt-Anchor" href="#1044-模板给出的位置"></a> 10.4.4. 模板给出的位置</h3>
<ol>
<li>函数模板一般是在头文件中给出完整的定义</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//file1.h</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span> &#123;<br>    T a;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-comment">//file1.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;file1.h&quot;</span></span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> S&lt;T&gt;::<span class="hljs-built_in">f</span>()&#123;...&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T x, T y)</span></span>&#123;<span class="hljs-keyword">return</span> x&gt;y?x:y;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-built_in">max</span>(a,b);<span class="hljs-comment">//实例化函数模板</span><br>    S&lt;<span class="hljs-type">int</span>&gt; x;<br>    x.<span class="hljs-built_in">f</span>();<br><span class="hljs-comment">//file2.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;file1.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">double</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">double</span>,<span class="hljs-type">double</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sub</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">max</span>(<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>);<span class="hljs-comment">//error</span><br>    S&lt;<span class="hljs-type">float</span>&gt; x;<br>    x.<span class="hljs-built_in">f</span>();<span class="hljs-comment">//error</span><br>&#125;<br><span class="hljs-comment">//不能通过编译，为什么？file2.cpp找不到max定义，也找不到完整的S代码</span><br></code></pre></td></tr></table></figure>
<h2 id="105-类的封装"><a class="markdownIt-Anchor" href="#105-类的封装"></a> 10.5. 类的封装</h2>
<ol>
<li>在头文件中放置类和类属函数的定义，而不放置实现。如果放置实现，则会建议编译器将其作为内联函数及逆行处理。
<ol>
<li>getter 和 setter 一般会作为内联函数。</li>
<li>内联函数一般会比较短</li>
</ol>
</li>
<li>在Cpp文件中放置类和类属函数的实现</li>
<li>声明全局对象的时候如果没有显式初始化，那么他已经完成了默认初始化。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//a.h 存储类的头文件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TDate</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">//只有函数签名</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetData</span><span class="hljs-params">(<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> m ,<span class="hljs-type">int</span> d)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">IsLeapYear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> year,month,day;<br>&#125;<br><span class="hljs-comment">//a.cpp 用来存储相应的实现部分</span><br><span class="hljs-comment">//TDate::命名空间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TDate::SetDate</span><span class="hljs-params">(<span class="hljs-type">int</span> y ,<span class="hljs-type">int</span> m ,<span class="hljs-type">int</span> d)</span></span>&#123;<br>    year = y;<br>    month = m;<br>    day = d;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">TDate::IsLeapYear</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (year%<span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> !=<span class="hljs-number">0</span>)||(year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1051-构造函数"><a class="markdownIt-Anchor" href="#1051-构造函数"></a> 10.5.1. 构造函数</h3>
<ol>
<li>默认构造函数:无参构造函数</li>
<li>构造函数可以设置为Private或者Public(默认)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">A</span>();<br>        <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i);<br>        <span class="hljs-built_in">A</span>(<span class="hljs-type">char</span> *p);<br>&#125;<br>A a1 = <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>);<br><span class="hljs-function">A <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-comment">//注意这种用法在函数回调的时候使用</span><br>A a1 = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//以上都是调A(int i)</span><br>A a2 = <span class="hljs-built_in">A</span>();<br>A a2;<br><span class="hljs-comment">//以上都是调A()，注意：不能写成：A a2();</span><br>A a3 = <span class="hljs-built_in">A</span>(<span class="hljs-string">&quot;abcd&quot;</span>);<br><span class="hljs-function">A <span class="hljs-title">a3</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>;<br>A a3 = <span class="hljs-string">&quot;abcd&quot;</span>;<br><span class="hljs-comment">//以上都是调A(char *)</span><br>A a[<span class="hljs-number">4</span>];<span class="hljs-comment">//调用a[0]、a[1]、a[2]、a[3]的A()</span><br>A b[<span class="hljs-number">5</span>]=&#123; <span class="hljs-built_in">A</span>(), <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">A</span>(<span class="hljs-string">&quot;abcd&quot;</span>), <span class="hljs-number">2</span>, <span class="hljs-string">&quot;xyz&quot;</span>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="1052-成员初始化表"><a class="markdownIt-Anchor" href="#1052-成员初始化表"></a> 10.5.2. 成员初始化表</h3>
<ol>
<li>成员初始化表:开辟空间的时候就赋值，而构造函数时在开辟空间结束之后再赋值，先于构造函数执行(按照成员变量声明顺序进行初始化)</li>
<li>成员初始化表可以降低编译器的压力</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CString</span>&#123;<br>    <span class="hljs-type">char</span> *p; <br>    <span class="hljs-type">int</span> size;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">CString</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">size</span>(x),<span class="hljs-built_in">p</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size])&#123;&#125;    <br>&#125;;<br></code></pre></td></tr></table></figure>
<ol start="3">
<li>在构造函数中尽量使用成员初始化表取代赋值动作(如果成员变量没有那么多，不然难以维护)</li>
<li>常量往往是通过成员初始化表的方式来完成初始化</li>
</ol>
<h3 id="1053-初始化顺序"><a class="markdownIt-Anchor" href="#1053-初始化顺序"></a> 10.5.3. 初始化顺序</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>	<span class="hljs-type">int</span> m;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">A</span>() &#123;<br>        m = <span class="hljs-number">0</span>; cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>	<span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> m1) &#123;<br>        m = m1;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(int m1)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>	<span class="hljs-type">int</span> x;<br>	A a;<span class="hljs-comment">//每一次创建类都优先创建</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">B</span>()&#123;<br>            x = <span class="hljs-number">0</span>; cout &lt;&lt; <span class="hljs-string">&quot;B()&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> x1)&#123;<br>            x = x1;<br>            cout &lt;&lt; <span class="hljs-string">&quot;B(int x1)&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> m1):<span class="hljs-built_in">a</span>(m1)&#123;<br>            x = x1;<br>            cout &lt;&lt; <span class="hljs-string">&quot;B(int x1, int m1)&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-comment">//不能在函数体里写A的构造函数(已经调过了)</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	B b1;<span class="hljs-comment">// 调用 B::B() 和 A::A()</span><br>	cout &lt;&lt; <span class="hljs-string">&quot;_______________&quot;</span> &lt;&lt; endl;<br>	<span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;   <span class="hljs-comment">// 调用 B::B(int) 和 A::A()</span><br>	cout &lt;&lt; <span class="hljs-string">&quot;_______________&quot;</span> &lt;&lt; endl;<br>	<span class="hljs-function">B <span class="hljs-title">b3</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">// 调用 B::B(int,int) 和 A::A(int) … </span><br>&#125;<br><span class="hljs-comment">//result:</span><br><span class="hljs-comment">//A()</span><br><span class="hljs-comment">//B()</span><br><span class="hljs-comment">//_______________</span><br><span class="hljs-comment">//A()</span><br><span class="hljs-comment">//B(int x1)</span><br><span class="hljs-comment">//_______________</span><br><span class="hljs-comment">//A(int m1)</span><br><span class="hljs-comment">//B(int x1, int m1)</span><br></code></pre></td></tr></table></figure>
<h3 id="1054-析构函数"><a class="markdownIt-Anchor" href="#1054-析构函数"></a> 10.5.4. 析构函数</h3>
<ol>
<li>格式:<code>~&lt;类名&gt;()</code></li>
<li>功能:RAII:Resource Acquisition Is Initialization(资源获取即初始化)</li>
<li>调用情况
<ol>
<li>对象消亡时，系统自动调用</li>
<li>C++离开作用域的时候回收</li>
<li>使用delete关键字的时候进行调用</li>
</ol>
</li>
<li>Private的析构函数：(强制自主控制对象存储分配)
<ol>
<li>回收对象的过程被接管，保证对象在堆上进行创建，但是不能使用delete，那么我们可以在内容提供一个destroy()方法来进行回收</li>
<li>写在栈或者全局区是不能通过编译的(自动调用，发现调不到)</li>
<li>强制在堆上进行创建，对很大的对象而言有好处强制管理存储分配</li>
<li>适用于内存栈比较小的嵌入式系统</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">A</span>();<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;&#125;<br>    <span class="hljs-keyword">private</span>:<br>        ~<span class="hljs-built_in">A</span>();<br>&#125;;<br><span class="hljs-comment">//析构函数私有，无法声明</span><br>A a;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    A aa;<span class="hljs-comment">//析构函数私有，无法声明</span><br>&#125;;<br>A *p = <span class="hljs-keyword">new</span> A;<span class="hljs-comment">//在堆上声明</span><br><span class="hljs-keyword">delete</span> p;<span class="hljs-comment">//错误</span><br>p-&gt;<span class="hljs-built_in">destroy</span>();<span class="hljs-comment">//可能出现p的null空指针问题</span><br><br><span class="hljs-comment">//Better Solution</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">free</span><span class="hljs-params">(A *p)</span></span>&#123; <span class="hljs-keyword">delete</span> p; &#125;<br>A::<span class="hljs-built_in">free</span>(p);<br></code></pre></td></tr></table></figure>
<h3 id="1055-拷贝构造函数"><a class="markdownIt-Anchor" href="#1055-拷贝构造函数"></a> 10.5.5. 拷贝构造函数</h3>
<ol>
<li>相同类型的类对象是通过拷贝构造函数来完成整个复制过程：自动调用：创建对象时，用一同类的对象对其初始化的时候进行调用。</li>
<li>默认拷贝构造函数
<ol>
<li>逐个成员初始化(member-wise initialization)</li>
<li>对于对象成员，该定义是递归的</li>
</ol>
</li>
<li>什么时候需要拷贝构造函数:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//赋值拷贝构造</span><br>A a;<br>A b=a;<br><span class="hljs-comment">//传参进行拷贝</span><br><span class="hljs-built_in">f</span>(A a)&#123;&#125;<br>A b;<br><span class="hljs-built_in">f</span>(b);<br><span class="hljs-comment">//返回值进行拷贝</span><br><span class="hljs-function">A <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>    A a;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-built_in">f</span>();<br><span class="hljs-comment">//拷贝构造函数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//const避免出现修改</span><br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a);<span class="hljs-comment">//一定要写引用，不然就递归调用了</span><br></code></pre></td></tr></table></figure>
<ol start="4">
<li>拷贝构造函数私有:目的是让编译器不能调用拷贝构造函数，防止对象按值传递，只能引用传递(对象比较大)</li>
<li>为什么对象是一个引用类型:不然会出现<strong>循环拷贝</strong>问题:如果没有引用的话，传参则会拷贝，那么就会出现循环拷贝,记住：<code>A(const A&amp; a)</code></li>
<li>没有深拷贝的需求的化，使用编译器提供的默认拷贝即可</li>
</ol>
<blockquote>
<p>拷贝函数的初始化</p>
</blockquote>
<ol>
<li>包含成员对象的类
<ol>
<li>默认拷贝构造函数:调用<strong>成员对象</strong>的<strong>拷贝构造函数</strong></li>
<li>自定义拷贝构造函数:调用成员对象的<strong>默认构造函数</strong>：程序员如果接管这件事情，则编译器不再负责任何默认参数。</li>
</ol>
</li>
<li>拷贝函数的拷贝过程没有处理静态数据成员</li>
<li>默认拷贝构造函数:
<ol>
<li>逐个成员初始化</li>
<li>对于对象成员，该定义是递归的</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <br>	<span class="hljs-type">int</span> x, y;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">A</span>() &#123; x = y = <span class="hljs-number">0</span>; &#125;<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123; x++; y++; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>	<span class="hljs-type">int</span> z;<br>	A a;<span class="hljs-comment">//已经默认创建了</span><br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">B</span>()&#123; z = <span class="hljs-number">0</span>; &#125;<br>		<span class="hljs-built_in">B</span>(<span class="hljs-type">const</span> B&amp; b):&#123; z = b.z; &#125;<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123; z++; a.<span class="hljs-built_in">inc</span>(); &#125;<span class="hljs-comment">//拷贝构造函数</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	B b1;    <span class="hljs-comment">//b1.z = b1.a.x = b1.a.y =0 </span><br>	b1.<span class="hljs-built_in">inc</span>();<span class="hljs-comment">//b1.a.x = b1.a.y = b1.z=1 </span><br>	<span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">(b1)</span></span>;<span class="hljs-comment">//b2.z=1 b2.a.x=0 b2.a.y=0,这个时候调用的是A的默认构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="106-const"><a class="markdownIt-Anchor" href="#106-const"></a> 10.6. Const</h2>
<h3 id="1061-常量指针和指针常量"><a class="markdownIt-Anchor" href="#1061-常量指针和指针常量"></a> 10.6.1. 常量指针和指针常量</h3>
<ol>
<li>常量指针:<code>const &lt;类型&gt; * &lt;指针变量&gt;</code>，不可以修改该指针指向的单元中的值，但是可以修改指向的单元。</li>
<li>在函数式编程中，可以通过对参数中的传递量添加const来保证不会修改原值。</li>
<li>指针常量:<code>&lt;类型&gt;* const&lt;指针变量&gt;</code>，指针在定义的时候初始化，可以修改该指针指向的单元中的值，但是不可以修改指向的单元。</li>
</ol>
<h3 id="1062-print函数的思考"><a class="markdownIt-Anchor" href="#1062-print函数的思考"></a> 10.6.2. print函数的思考</h3>
<ol>
<li>注意变量指针位置上不能传入常量值，但是常量指针上可以传入常量</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span></span>&#123;<br>    cout &lt;&lt; *p &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c = <span class="hljs-number">8</span>;<br><span class="hljs-built_in">print</span>(c) ;<span class="hljs-comment">//不可以被调用的</span><br><span class="hljs-built_in">print</span>(&amp;c);<span class="hljs-comment">//C++赋给的权利，在调用的时候除去常量的特性，这个&amp;是强制类型转换，取消常量特性</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> *p)</span></span>&#123;<span class="hljs-comment">//如此修改就可以大量复用</span><br>    <span class="hljs-comment">//常量使用者和变量使用者都可以使用</span><br>    cout &lt;&lt; *p &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1063-常量成员函数"><a class="markdownIt-Anchor" href="#1063-常量成员函数"></a> 10.6.3. 常量成员函数</h3>
<ol>
<li>声明为const的对象只能调用常成员对象函数</li>
<li>如果是非const的对象，则都可以进行调用</li>
<li>是否const方法真的就不能修改对象里面的值了呢？不是,const只是语法上避免了，但是不是完全不可修改
<ol>
<li>关键词<code>mutable</code>:表示成员可以再const中进行修改，而不是用间接的方式来做。</li>
<li>去掉const转换:<code>(const_cast)&lt;A*&gt;(this)-&gt;x</code>转换后可以修改原来的成员</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1);<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">//前后要保证一致，const在后面</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">A::f</span><span class="hljs-params">()</span></span>&#123;x = <span class="hljs-number">1</span>; y = <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//编译器怎么能发现不是const的？转化为防止变量被赋值，见下面，所以const指针不能修改</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(A * <span class="hljs-type">const</span> <span class="hljs-keyword">this</span>)</span></span>;<span class="hljs-comment">//上面的函数相当于这个</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">A::show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;cout &lt;&lt;x &lt;&lt; y;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">const</span> A* <span class="hljs-type">const</span> <span class="hljs-keyword">this</span>)</span></span>;<span class="hljs-comment">//上面的函数相当于这个，第一个const表示指向对象常量，后一个const表示指针本身是常量</span><br><br><span class="hljs-function"><span class="hljs-type">const</span> A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//常对象:这个对象是不可以修改的</span><br>a.<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//错误，常对象无法调用非常方法</span><br>a.<span class="hljs-built_in">show</span>();<span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure>
<h2 id="107-static"><a class="markdownIt-Anchor" href="#107-static"></a> 10.7. Static</h2>
<h3 id="1071-静态成员变量"><a class="markdownIt-Anchor" href="#1071-静态成员变量"></a> 10.7.1. 静态成员变量</h3>
<ol>
<li>一个类只有一个，初始化放在类外部，只能初始化一次</li>
<li>为什么声明为静态，而不是全局？
<ol>
<li>避免名污染问题</li>
<li>避免数据泄漏</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-type">int</span> x,y;<br>	<span class="hljs-type">static</span> <span class="hljs-type">int</span> shared;<br>&#125;;<br><span class="hljs-type">int</span> A::shared=<span class="hljs-number">0</span>;<span class="hljs-comment">//j静态成员的初始化放在类的外部，只能被赋值一次，所以不再头文件中定义，而是在实现中定义，避免重复。并且定义的时候不用再写static</span><br></code></pre></td></tr></table></figure>
<h3 id="1072-静态成员函数"><a class="markdownIt-Anchor" href="#1072-静态成员函数"></a> 10.7.2. 静态成员函数</h3>
<ol>
<li><strong>只能存取静态成员变量，调用静态成员函数</strong></li>
<li>遵循类访问控制：在类上直接访问只能是静态成员变量</li>
<li>类也是一种对象，可以通过类直接调用静态方法</li>
</ol>
<h3 id="1073-访问静态成员"><a class="markdownIt-Anchor" href="#1073-访问静态成员"></a> 10.7.3. 访问静态成员</h3>
<ol>
<li>通过对象使用:<code>A a;a.f();</code></li>
<li>通过类使用:<code>A::f();</code></li>
<li>例子：查看已经创建的实例数量</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> obj_count;<br>	<span class="hljs-keyword">public</span>:<br>	    <span class="hljs-built_in">A</span>()&#123;obj_count++;&#125;<span class="hljs-comment">//追踪创建了多少个对象</span><br>	    ~<span class="hljs-built_in">A</span>()&#123;obj_count--;&#125;<br>	    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">get_num_of_obj</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//查看已经创建了多少个对象</span><br>&#125;;<br><span class="hljs-type">int</span> A::obj_count=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">A::get_num_of_obj</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> obj_count; &#125;<br></code></pre></td></tr></table></figure>
<h2 id="108-单件模式"><a class="markdownIt-Anchor" href="#108-单件模式"></a> 10.8. 单件模式</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span>  <span class="hljs-title class_">singleton</span>&#123;<br>    <span class="hljs-keyword">protected</span>:<span class="hljs-comment">//构造函数外部不可以使用</span><br>		<span class="hljs-built_in">singleton</span>()&#123;&#125;<br>		<span class="hljs-built_in">singleton</span>(<span class="hljs-type">const</span> singleton &amp;);<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-function"><span class="hljs-type">static</span> singleton *<span class="hljs-title">instance</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span>  m_instance == <span class="hljs-literal">NULL</span>? <br>			m_instance = <span class="hljs-keyword">new</span> singleton: m_instance;<br>		&#125;<br>		<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span>  </span>&#123; <span class="hljs-keyword">delete</span> m_instance; m_instance = <span class="hljs-literal">NULL</span>; &#125;<br>	<span class="hljs-keyword">private</span>:<br>		<span class="hljs-type">static</span> singleton *m_instance;<span class="hljs-comment">//保存对象的指针也是static的</span><br>&#125;;<br>singleton *singleton::m_instance= <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//初始化</span><br></code></pre></td></tr></table></figure>
<h2 id="109-继承"><a class="markdownIt-Anchor" href="#109-继承"></a> 10.9. 继承</h2>
<ol>
<li>声明的时候不需要声明继承</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//错误声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Undergraduated_Student</span> : <span class="hljs-keyword">public</span> Student;<span class="hljs-comment">//声明的时候是不用声明继承的</span><br><span class="hljs-comment">//正确声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Undergraduated_Student</span>;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>派生类中对父类的重名方法是重写,期望被重写的部分的前面添加<code>Virtual</code>来保证子类重写。</li>
<li>父类中的所有部分都会被子类的名空间覆盖，但是通过命名空间也可以访问，如果父类中的public方法没有被子类复写，则可以调用</li>
<li>构造函数、析构函数和运算符重载函数是不会被继承的。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//显式继承A的构造函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">using</span> A::A;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1091-单继承"><a class="markdownIt-Anchor" href="#1091-单继承"></a> 10.9.1. 单继承</h3>
<ol>
<li>protected:
<ol>
<li>如果没有继承的话，protected和private的访问权限是相同的</li>
<li>派生类可以访问基类中protected的属性的成员。</li>
<li>派生类不可以访问<strong>基类中的对象</strong>的protected的属性。</li>
<li><strong>派生类含有基类的所有成员变量</strong></li>
</ol>
</li>
<li>子类修改访问权限</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">char</span> nickname[<span class="hljs-number">16</span>];<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Undergraduated_Student</span>: <span class="hljs-keyword">public</span> Student &#123;&#125;<br>    <span class="hljs-keyword">private</span>:<br>        Student::nickname;<span class="hljs-comment">//这样在才能修改可见性</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="10911-继承方式"><a class="markdownIt-Anchor" href="#10911-继承方式"></a> 10.9.1.1. 继承方式</h4>
<ol>
<li>public继承:<code>class A: public B</code>
<ol>
<li>原来的public是public，原来的private是private</li>
<li>如果没有特殊需要建议使用public</li>
<li>IS A关系</li>
</ol>
</li>
<li>private继承:<code>class A: private B</code>
<ol>
<li>private:原来所有的都是private，但是这个private是对于Undergraduate_Student大对象而言，所以他自己还是可以访问的。</li>
<li>默认的继承方式</li>
<li>Has A关系</li>
</ol>
</li>
</ol>
<h4 id="10912-继承的初始化顺序"><a class="markdownIt-Anchor" href="#10912-继承的初始化顺序"></a> 10.9.1.2. 继承的初始化顺序</h4>
<ol>
<li>派生类对象的初始化：由基类和派生类共同完成</li>
<li>构造函数的执行次序
<ol>
<li>基类的构造函数</li>
<li>派生类对象成员类的构造函数(注意！)</li>
<li>派生类的构造函数</li>
</ol>
</li>
<li>析构函数的执行次序(与构造函数执行顺序相反)
<ol>
<li>派生类的析构函数</li>
<li>派生类对象成员类的析构函数</li>
<li>基类的析构函数</li>
</ol>
</li>
<li>基类构造函数的调用
<ul>
<li>缺省执行基类默认构造函数</li>
<li>如果要执行基类的<strong>非默认构造函数</strong>，则必须在派生类构造函数的成员初始化表中指出</li>
</ul>
</li>
</ol>
<h3 id="1092-多继承"><a class="markdownIt-Anchor" href="#1092-多继承"></a> 10.9.2. 多继承</h3>
<ol>
<li>多继承语法</li>
</ol>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bnf">class <span class="hljs-attribute">&lt;派生类名&gt;</span>：[<span class="hljs-attribute">&lt;继承方式&gt;</span>] <span class="hljs-attribute">&lt;基类名1&gt;</span>，<br>                 [<span class="hljs-attribute">&lt;继承方式&gt;</span>] <span class="hljs-attribute">&lt;基类名2&gt;</span>，…<br>&#123;〈成员表〉&#125;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>名冲突则使用命名空间来解决</li>
</ol>
<h4 id="10921-基类声明顺序初始化顺序"><a class="markdownIt-Anchor" href="#10921-基类声明顺序初始化顺序"></a> 10.9.2.1. 基类声明顺序(初始化顺序)</h4>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/C++-OOP/img/11.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<ol>
<li>基类的声明次序决定：
<ol>
<li>对基类构造函数/析构函数的调用次序(顶部基类，同层基类按照声明顺序) 上图中就是 ABCD的顺序</li>
<li>对基类数据成员的存储安排</li>
</ol>
</li>
<li>析构函数正好相反</li>
</ol>
<h4 id="10922-虚基类"><a class="markdownIt-Anchor" href="#10922-虚基类"></a> 10.9.2.2. 虚基类</h4>
<ol>
<li>如果直接基类有公共的基类，则该公共基类中的成员变量在多继承的派生类中有<strong>多</strong>个副本</li>
<li>如果有一个公共的虚基类，则成员变量只有<strong>一</strong>个副本</li>
<li>类D有两个x成员，B::x,C::x</li>
<li>虚继承:保留一个虚指针
<ol>
<li>虚指针指向A</li>
<li>可以认为是一个组合关系</li>
</ol>
</li>
<li>合并</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> A;<br><span class="hljs-comment">//public virtual 和 virtual public是一致的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: B, C;<br></code></pre></td></tr></table></figure>
<h2 id="1010-虚函数"><a class="markdownIt-Anchor" href="#1010-虚函数"></a> 10.10. 虚函数</h2>
<ol>
<li>一个类只有一个虚函数表</li>
<li>虚函数是指一个类中你希望重载的成员函数，但你使用一个基类指针或引用指向一个继承类对象的时候，调用一个虚函数时，实际调用的就是继承类的版本。</li>
<li><strong>如基类中被定义为虚成员函数，则派生类中对其重定义的成员函数均为虚函数</strong></li>
</ol>
<h3 id="10101-类型相容和赋值兼容"><a class="markdownIt-Anchor" href="#10101-类型相容和赋值兼容"></a> 10.10.1. 类型相容和赋值兼容</h3>
<ol>
<li>类型相容:
<ol>
<li>类型相容是指完全相同的(别名)</li>
<li>一个类型是另一个类型的子类型(int -&gt; long int)</li>
</ol>
</li>
<li>赋值相容(不会丢失信息):对于类型相同的变量才有(a = b)
<ol>
<li>如果类型相同可以直接赋值</li>
<li>子类型可以赋值给父类型</li>
</ol>
<ul>
<li><code>A a; B b; class B: public A</code>
<ul>
<li>对象的身份发生变化(a和b都代表栈上对应大小的内存),B类型对象变为了A类型的对象</li>
<li>属于派生类的属性已不存在</li>
<li>将派生类对象赋值给基类对象-&gt;对象切片</li>
</ul>
</li>
<li><code>A a = b</code>:调用拷贝构造函数</li>
<li><code>const A &amp;a</code>:函数必然包含的拷贝构造函数中的参数</li>
<li><code>B* pb; A* pa = pb; class B: public A</code>
<ul>
<li>因为是赋值相容的，所以可以指针赋值</li>
<li>这种情况类似Java</li>
</ul>
</li>
<li><code>B b; A &amp; a=b; class B: public A</code>：对象身份没有发生变化(还是B)</li>
</ul>
</li>
<li>传参的时候尽量不要拷贝传参(存在对象切片问题)，而是使用引用传参。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A&#123;<br>    <span class="hljs-type">int</span> z;<br>    <span class="hljs-keyword">public</span>:<br>	    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>	    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-comment">//把派生类对象赋值给基类对象</span><br>A a;<br>B b;<br>a = b;     <span class="hljs-comment">//OK, </span><br>b = a;     <span class="hljs-comment">//Error</span><br>a.<span class="hljs-built_in">f</span>();     <span class="hljs-comment">//A::f()</span><br><br><span class="hljs-comment">//基类的引用或指针可以引用或指向派生类对象</span><br>A &amp;r_a = b;     <span class="hljs-comment">//OK</span><br>A *p_a = &amp;b;    <span class="hljs-comment">//OK</span><br><br>B &amp;r_b = a;     <span class="hljs-comment">//Error</span><br>B *p_b = &amp;a；   <span class="hljs-comment">//Error</span><br><span class="hljs-comment">//这里通过赋值相容，已经对对象完成了切片</span><br><span class="hljs-built_in">func1</span>(A&amp; a)&#123;a.<span class="hljs-built_in">f</span>();&#125;<br><span class="hljs-built_in">func1</span>(b);<span class="hljs-comment">//A::f</span><br></code></pre></td></tr></table></figure>
<h3 id="10102-绑定时间"><a class="markdownIt-Anchor" href="#10102-绑定时间"></a> 10.10.2. 绑定时间</h3>
<h4 id="101021-静态绑定前期"><a class="markdownIt-Anchor" href="#101021-静态绑定前期"></a> 10.10.2.1. 静态绑定(前期)</h4>
<ol>
<li>编译时刻确定调用哪一个方法</li>
<li>依据对象的静态类型</li>
<li>效率高、灵活性差</li>
<li>静态绑定根据形参决定</li>
</ol>
<h4 id="101022-动态绑定late-binding"><a class="markdownIt-Anchor" href="#101022-动态绑定late-binding"></a> 10.10.2.2. 动态绑定(Late Binding)</h4>
<ol>
<li>晚绑定是指编译器或者解释器在运行前不知道对象的类型，使用晚绑定，无需检查对象的类型，只需要检查对象是否支持特性和方法即可。</li>
<li>c++中晚绑定常常发生在使用<code>virtual</code>声明成员函数</li>
<li>运行时刻确定，依据对象的实际类型(动态)</li>
<li>灵活性高、<strong>效率低</strong></li>
<li>动态绑定函数也就是虚函数。</li>
<li>直到构造函数返回之后，对象方可正常使用</li>
<li>C++默认的都是静态绑定，Java默认的都是动态绑定</li>
</ol>
<blockquote>
<p>虚函数表</p>
</blockquote>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/C++-OOP/img/2.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<ul>
<li>p-&gt;f():需要寻找a和b中的f()函数地址</li>
<li>如果不能明确虚函数个数，没有办法索引</li>
<li>虚函数表(索引表,vtable):大小可变
<ul>
<li>首先构造基类的虚函数表</li>
<li>然后对派生类中的函数，如果查找了，则会覆盖对应函数来生成虚函数表</li>
</ul>
</li>
<li>对象内存空间中含有指针指向虚函数表</li>
<li><code>(**((char *)p - 4))(p)</code>:f的函数调用(从虚函数表拿数据),p是参数this</li>
<li>空间上和时间上都付出了代价
<ul>
<li>空间:存储虚函数表指针和虚函数表</li>
<li>时间:需要通过虚函数表查找对应函数地址，多调用</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>	    <span class="hljs-built_in">A</span>() &#123; <span class="hljs-built_in">f</span>();&#125;<br>	    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>	    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-built_in">f</span>();<br>            <span class="hljs-built_in">g</span>();<br>        &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A<br>&#123;   <span class="hljs-keyword">public</span>:<br>	    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>	    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br>&#125;;	<br><span class="hljs-comment">//直到构造函数返回之后，对象方可正常使用</span><br><span class="hljs-comment">//函数调用顺序，重要考试题，依据虚函数表</span><br>B b;      <span class="hljs-comment">// A::A()，A::f, B::B(),为什么调用A的f而不是B的？因为名空间以及B没有构造。 </span><br>A *p= &amp;b;<br>p-&gt;<span class="hljs-built_in">f</span>();   <span class="hljs-comment">//B::f，虚函数</span><br>p-&gt;<span class="hljs-built_in">g</span>();   <span class="hljs-comment">//A::g，g是静态绑定</span><br>p-&gt;<span class="hljs-built_in">h</span>();   <span class="hljs-comment">//A::h, B::f, A::g</span><br></code></pre></td></tr></table></figure>
<ul>
<li>尽量不要在构造函数中调用虚函数</li>
<li>此时的虚函数就是和构造函数名空间相同</li>
<li>h()函数是非虚接口
<ul>
<li>有不同的实现:调用了虚函数和非虚函数</li>
<li>可以替换部分的实现</li>
<li>可以使得非虚函数具有虚函数的特性(让全局函数具有多态:将全局函数做成非虚接口)</li>
</ul>
</li>
</ul>
<h3 id="10103-虚函数限制"><a class="markdownIt-Anchor" href="#10103-虚函数限制"></a> 10.10.3. 虚函数限制</h3>
<ol>
<li>类的成员函数才可以是虚函数:全局函数不可以是虚函数</li>
<li>静态成员函数不能是虚函数:静态的成员函数属于类，并不属于一个对象，所以不能虚函数</li>
<li>内联成员函数不能是虚函数:内联成员函数在编译的时候就已经确定了</li>
<li>构造函数不能是虚函数:
<ol>
<li>因为创建类的时候是自动调用的，父类的指针无法直接调用，虚函数没有意义</li>
<li>虚函数表是在构造函数中完成的</li>
</ol>
</li>
<li>析构函数可以(往往)是虚函数：如果不是虚函数，不好调用到派生类中的析构函数(delete一个父类指针，如果非虚，不能调用到派生类的析构函数)
<ol>
<li>如果有继承的话，最好使用虚析构函数，在调用析构的函数，会<strong>先</strong>调用基类的析构函数，所以:</li>
<li>在析构函数中，只需要析构派生类自己的资源就可以了</li>
</ol>
</li>
</ol>
<h3 id="10104-override和final关键字"><a class="markdownIt-Anchor" href="#10104-override和final关键字"></a> 10.10.4. override和final关键字</h3>
<ul>
<li>override:希望以虚函数的形式写:编译器报错，防止漏写virtual问题</li>
<li>final:不可以再次重写</li>
</ul>
<h3 id="10105-不要定义与继承而来的非虚成员函数同名的成员函数"><a class="markdownIt-Anchor" href="#10105-不要定义与继承而来的非虚成员函数同名的成员函数"></a> 10.10.5. 不要定义与继承而来的非虚成员函数同名的成员函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>	    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: <span class="hljs-keyword">public</span> B &#123; <br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span></span>;<br>&#125;;<br>D x;<br>B* pB = &amp;x;<br>pB-&gt;<span class="hljs-built_in">mf</span>();<span class="hljs-comment">//B:mf</span><br>D* pD = &amp;x;<br>pD-&gt;<span class="hljs-built_in">mf</span>();<span class="hljs-comment">//D:mf</span><br></code></pre></td></tr></table></figure>
<ul>
<li>这样子的话，同一个对象使用不同指针会有不同的行为。</li>
</ul>
<h3 id="10106-绝对不要重新定义继承而来的缺省参数值"><a class="markdownIt-Anchor" href="#10106-绝对不要重新定义继承而来的缺省参数值"></a> 10.10.6. 绝对不要重新定义继承而来的缺省参数值！</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>)</span> </span>=<span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>)</span> </span><br><span class="hljs-function">        </span>&#123; cout &lt;&lt; x;&#125;<br>&#125;;<br>A *p_a;<br>B b;<br>p_a = &amp;b; <br>p_a-&gt;<span class="hljs-built_in">f</span>();<span class="hljs-comment">//0</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">public</span> A&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; cout&lt;&lt; x;&#125;<br>&#125;;<br>A *p_a1;<br>C c;<br>p_a1 = &amp;c; <br>p_a1-&gt;<span class="hljs-built_in">f</span>();<span class="hljs-comment">//0</span><br><span class="hljs-comment">//对象中只记录虚函数的入口地址</span><br></code></pre></td></tr></table></figure>
<ul>
<li>虚函数表上只记录了第一个(最近根)的缺省值</li>
</ul>
<h2 id="1011-纯虚函数和抽象类"><a class="markdownIt-Anchor" href="#1011-纯虚函数和抽象类"></a> 10.11. 纯虚函数和抽象类</h2>
<h3 id="10111-纯虚函数-java中的接口"><a class="markdownIt-Anchor" href="#10111-纯虚函数-java中的接口"></a> 10.11.1. 纯虚函数 Java中的接口</h3>
<ol>
<li>声明时在函数原型后面加上 <strong>= 0</strong>:<code>virtual int f() = 0;</code></li>
<li><strong>往往</strong>只给出函数声明，不给出实现：可以给出实现，通过函数外进行定义(但是不好访问，因为查到是0)</li>
<li>子类必须继承接口，并给出实现</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>    Base::f;<span class="hljs-comment">//显式调用基类中纯虚函数的定义</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="10112-抽象类"><a class="markdownIt-Anchor" href="#10112-抽象类"></a> 10.11.2. 抽象类</h3>
<ol>
<li>至少包含一个纯虚函数</li>
<li>不能用于创建对象:抽象类类似一个接口，提供一个框架</li>
<li>为派生类提供框架，派生类提供抽象基类的所有成员函数的实现</li>
</ol>
<h2 id="1012-抽象工厂模式"><a class="markdownIt-Anchor" href="#1012-抽象工厂模式"></a> 10.12. 抽象工厂模式</h2>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/C++-OOP/img/5.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<ul>
<li>Step1:提供Windows GUI类库：WinButton</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">WinButton *pb= <span class="hljs-keyword">new</span> <span class="hljs-built_in">WinButton</span>();<br>pb-&gt;<span class="hljs-built_in">SetStyle</span>();<br>WinLabel *pl = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WinLabel</span>();<br>pl-&gt;<span class="hljs-built_in">SetText</span>();<br></code></pre></td></tr></table></figure>
<ul>
<li>step2:增加对Mac的支持:MacButton，MacLabel</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">MacButton *pb= <span class="hljs-keyword">new</span> <span class="hljs-built_in">MacButton</span>();<br>pb-&gt;<span class="hljs-built_in">SetStyle</span>();<br>MacLabel *pl = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MacLabel</span>();<br>pl-&gt;<span class="hljs-built_in">SetText</span>();<br></code></pre></td></tr></table></figure>
<ul>
<li>step3:增加用户跨平台设计的支持
<ul>
<li>将Button抽象出来</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++">Button *pb= <span class="hljs-keyword">new</span> <span class="hljs-built_in">MacButton</span>();<br>pb-&gt;<span class="hljs-built_in">SetStyle</span>();<br>Label *pl = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MacLabel</span>();<br>pl-&gt;<span class="hljs-built_in">SetText</span>();<br><span class="hljs-comment">//创建工厂来保证创建的正确性</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Button* <span class="hljs-title">CreateButton</span><span class="hljs-params">()</span> </span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Label* <span class="hljs-title">CreateLabel</span><span class="hljs-params">()</span> </span>=<span class="hljs-number">0</span>;<br>&#125;; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MacFactory</span>: <span class="hljs-keyword">public</span> AbstractFactory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">MacButton* <span class="hljs-title">CreateButton</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MacButton; &#125;<br>    <span class="hljs-function">MacLabel* <span class="hljs-title">CreateLabel</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MacLabel; &#125;<br>&#125;; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WinFactory</span>: <span class="hljs-keyword">public</span> AbstractFactory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">WinButton* <span class="hljs-title">CreateButton</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WinButton; &#125;<br>    <span class="hljs-function">WinLabel*   <span class="hljs-title">CreateLabel</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WinLabel; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span>; <span class="hljs-comment">// Abstract Class </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MacButton</span>: <span class="hljs-keyword">public</span> Button &#123;&#125;; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WinButton</span>: <span class="hljs-keyword">public</span> Button &#123;&#125;; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Label</span>; <span class="hljs-comment">// Abstract Class </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MacLabel</span>: <span class="hljs-keyword">public</span> Label &#123;&#125;; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WinLabel</span>: <span class="hljs-keyword">public</span> Label &#123;&#125;;<br>AbstractFactory* fac;<br><span class="hljs-keyword">switch</span> (style) &#123;<br><span class="hljs-keyword">case</span> MAC:<br>    fac = <span class="hljs-keyword">new</span> MacFactory;<br>    <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> WIN:<br>    fac = <span class="hljs-keyword">new</span> WinFactory;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br>Button* button = fac-&gt;<span class="hljs-built_in">CreateButton</span>();<br>Label* Label = fac-&gt;<span class="hljs-built_in">CreateLabel</span>();<br></code></pre></td></tr></table></figure>
<ul>
<li>抽象工厂模式的类图<br />
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/C++-OOP/img/6.png" srcset="/img/loading.gif" lazyload alt="" /></li>
</ul>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/2020-C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="category-chain-item">2020-C++高级程序设计</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%80%83%E8%AF%95/">#考试</a>
      
        <a href="/tags/C/">#C++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>2020-C++高级程序设计-C++ exam</div>
      <div>https://spricoder.github.io/2020/07/01/2020-C-plus-plus-advanced-programming/2020-C-plus-plus-advanced-programming-C++%20exam/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>SpriCoder</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年7月1日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/07/01/2020-C-plus-plus-advanced-programming/2020-C-plus-plus-advanced-programming-exam-final/" title="2020-C++高级程序设计-exam-final">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">2020-C++高级程序设计-exam-final</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/07/01/2020-C-plus-plus-advanced-programming/2020-C-plus-plus-advanced-programming-%E4%BD%9C%E4%B8%9A%E6%80%BB%E7%BB%93/" title="2020-C++高级程序设计-作业总结">
                        <span class="hidden-mobile">2020-C++高级程序设计-作业总结</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'SpriCoder/spricoder-blog-comment');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
  </div>
  <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  <!-- <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      京ICP证123456号
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
          
          <span>京公网安备12345678号</span>
        </a>
      </span>
    
  
</div>
 -->
  
</footer>
  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  
    <script  src="/js/img-lazyload.js" ></script>
  



  <script  src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var title = subtitle.title;
      
        typing(title);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  





  
<script>
  Fluid.utils.createScript('https://cdn.staticfile.org/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.staticfile.org/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
