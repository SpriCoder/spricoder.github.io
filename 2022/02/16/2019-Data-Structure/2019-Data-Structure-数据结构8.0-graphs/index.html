

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/project/img/avatar.png">
  <link rel="icon" href="/project/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="SpriCoder">
  <meta name="keywords" content="">
  
    <meta name="description" content="2019-Data-Structure-数据结构8.0-graphs">
<meta property="og:type" content="article">
<meta property="og:title" content="2019-Data-Structure-数据结构8.0-graphs">
<meta property="og:url" content="https://stormbroken.github.io/project/2022/02/16/2019-Data-Structure/2019-Data-Structure-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%848.0-graphs/index.html">
<meta property="og:site_name" content="SpriCoder的博客">
<meta property="og:description" content="2019-Data-Structure-数据结构8.0-graphs">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/1.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/2.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/3.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/4.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/9.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/5.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/6.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/7.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/8.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/10.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/11.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/13.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/14.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/15.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/12.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/16.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/17.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/18.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/19.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/20.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/21.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/22.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/23.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/24.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/25.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/26.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/27.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/28.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/29.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/30.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/31.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/32.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/33.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/34.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/35.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/36.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/37.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/36.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/38.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/39.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/40.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/41.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/42.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/43.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/44.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/61.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/62.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/63.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/64.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/65.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/45.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/46.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/47.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/48.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/49.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/50.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/51.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/52.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/53.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/66.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/54.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/55.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/56.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/57.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/58.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/59.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/60.png">
<meta property="article:published_time" content="2022-02-16T11:09:54.000Z">
<meta property="article:modified_time" content="2022-02-16T11:51:53.103Z">
<meta property="article:author" content="SpriCoder">
<meta property="article:tag" content="课程笔记">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="图算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/1.png">
  
  
  <title>2019-Data-Structure-数据结构8.0-graphs - SpriCoder的博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.staticfile.org/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/project/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/project/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/project/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"stormbroken.github.io","root":"/project/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"DYxfU2PHurs2yXd95Sq85bU2-gzGzoHsz","app_key":"YWKSJ5KaDC4GQh2F8JraQPBr","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/project/local-search.xml"};
  </script>
  <script  src="/project/js/utils.js" ></script>
  <script  src="/project/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/project/">
      <strong>SpriCoder的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/project/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/project/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/project/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/project/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/project/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/project/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          <span id="subtitle" title="Everyday is today.">
            
          </span>
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-02-16 19:09" pubdate>
          2022年2月16日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          23k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          189 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">2019-Data-Structure-数据结构8.0-graphs</h1>
            
            <div class="markdown-body">
              
              <h2 id="graphs"><a class="markdownIt-Anchor" href="#graphs"></a> Graphs</h2>
<h1 id="1-图的定义"><a class="markdownIt-Anchor" href="#1-图的定义"></a> 1. 图的定义</h1>
<ol>
<li>Graph = (V, E)
<ol>
<li>V: nonempty finite vertice set(顶点集)  一个非空确定顶点个数的集合</li>
<li>E: edge set(边集)</li>
</ol>
</li>
</ol>
<h2 id="11-有向图"><a class="markdownIt-Anchor" href="#11-有向图"></a> 1.1. 有向图</h2>
<ol>
<li>If the tuple denoting an edge is ordered, then &lt;v1,v2&gt; and &lt;v2,v1&gt; are different edges. (如果表示的边的<strong>元组是有序</strong>的，也就是&lt;v1,v2&gt;和&lt;v2,v1&gt;是不同的)</li>
<li>v1: 有向图边的始点</li>
<li>v2: 有向图边的终点</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/1.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="4">
<li>In a directed graph with n nodes, the number of edges &lt;=n*(n-1). If “=” is satisfied, then it is called a complete directed graph.(一个有n个节点的有向图，其边的个数&lt;= n*(n-1)，如果相等，则为是一个完全有向图)</li>
<li>完全图(有向完全图):指有向图中每两个顶点都相互指向。</li>
</ol>
<h2 id="12-无向图"><a class="markdownIt-Anchor" href="#12-无向图"></a> 1.2. 无向图</h2>
<ol>
<li>If the tuple denoting an edge is unordered, then (v1,v2) and (v2,v1) are the same edge.(如果表示边的<strong>元组是无序</strong>的，则(v1，v2)和(v2，v1)是相同的边。)</li>
<li>In an undirected graph with n nodes,  the number of edges &lt;= n*(n-1)/2. If “=” is satisfied, then it is called a complete undirect graph.(在一个有n个顶点的无向图中，边的个数 &lt;= n(n-1)/2，如果刚好相等，则被称为完全无向图)</li>
<li>完全图(无向完全图):就是指每两个顶点之间都有一条边。</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/2.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h2 id="13-其他图"><a class="markdownIt-Anchor" href="#13-其他图"></a> 1.3. 其他图</h2>
<ol>
<li>以下两种图在我们的数据结构中不进行讨论</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/3.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="2">
<li>不考虑 自环(ring) 和 多重边 的多重图。</li>
</ol>
<h2 id="14-顶点的度数"><a class="markdownIt-Anchor" href="#14-顶点的度数"></a> 1.4. 顶点的度数</h2>
<ol>
<li>对于无向图只有度数，而对于有向图不仅仅有入度，还有出度。</li>
<li>degree d<sub>v</sub> of vertex v, TD(v): is the number of edges incident on vertex v. In a directed graph :(顶点v的度数为d<sub>v</sub>，TD(V)是顶点v的度数，在有向图中)
<ol>
<li>in-degree of vertex v is the number of edges incident to v, ID(v).(顶点v的入度是指向顶点v的边的个数)</li>
<li>out-degree of vertex v is the number of edges incident from the v, OD(v). (顶点v的出度从v出发的边的个数)</li>
</ol>
</li>
<li>性质:(度数)TD(v)=ID(v)+OD(v)</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/4.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h2 id="15-图的性质"><a class="markdownIt-Anchor" href="#15-图的性质"></a> 1.5. 图的性质</h2>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/9.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol>
<li>所有的度数加起来是边的个数的两倍。</li>
</ol>
<h2 id="16-子图"><a class="markdownIt-Anchor" href="#16-子图"></a> 1.6. 子图</h2>
<ol>
<li>Graph G=(V,E),G’=(V‘,E‘), if V’包含于V, E’包含于E, and the vertices incident on the edges in E’ are in V’, then G’ is the subgraph of G. For example: 如果图G和图G’，如果V’包含于V，E’包含于E,并且E’中顶点的边也在G’中，那么G’是G的子图</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/5.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h2 id="17-路径path"><a class="markdownIt-Anchor" href="#17-路径path"></a> 1.7. 路径(path)</h2>
<ol>
<li>A sequence of vertices P=i<sub>1</sub>,i<sub>2</sub>,……i<sub>k</sub> is an i<sub>1</sub> to i<sub>k</sub> path in the graph of graph G=(V,E) iff the edge(i<sub>j</sub>,i<sub>j+1</sub>)is in E for every j, 1 &lt;= j &lt; k.(在图 G=(V，E)中，如果每j的边(i<sub>j</sub>，i<sub>j+1</sub>)在E中，1&lt;= j&lt; k，则顶点序列P=i<sub>1</sub>，i<sub>2</sub>，…,i<sub>k</sub>是i<sub>1</sub>到i<sub>k</sub>的路径。)</li>
</ol>
<h2 id="18-简单路径和环simple-path-and-cycle"><a class="markdownIt-Anchor" href="#18-简单路径和环simple-path-and-cycle"></a> 1.8. 简单路径和环(Simple path and cycle)</h2>
<ol>
<li>A Simple path is a path in which all vertices except possibly the first and last , are different.(简单路径 : 路径除了第一个和最后一个顶点中<strong>没有出现相同</strong>的顶点)</li>
<li>A Simple cycle is a simple path with the same start and end vertex.(简单回路:起点和终点相同的时候的简单路径)</li>
</ol>
<h2 id="19-连通图和连通分量connected-graph-connected-component"><a class="markdownIt-Anchor" href="#19-连通图和连通分量connected-graph-connected-component"></a> 1.9. 连通图和连通分量(Connected graph &amp; Connected component)</h2>
<ol>
<li>In a undirected graph, if there is a path from vertex v1 to v2, then v1 and v2 are connected.(在无向图中，如果v1到v2之间有一条路径，那么v1和v2是连通的)</li>
<li>In a undirected graph ,if two arbitrary vertices are connected, then the graph is a connected graph(在无向图中，如果任意两个顶点是连通的，则该图是连通图)</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/6.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="3">
<li>极大连通子图:就是结点个数最多的连通的子图。</li>
</ol>
<h2 id="110-强联通图和强联通分量strong-connected-graph-and-strongly-connected-component"><a class="markdownIt-Anchor" href="#110-强联通图和强联通分量strong-connected-graph-and-strongly-connected-component"></a> 1.10. 强联通图和强联通分量(Strong connected graph and strongly connected component)</h2>
<ol>
<li>A digraph is strongly connected iff it contains a directed path from i to j and from j to i for every pair of distinct vertices i and j.(有向图是强连通的，当它包含从 i 到 j 和从 j 到 i 的有向路径时，对于每对不同的顶点 i 和 j)。
<ul>
<li>简单来说就是既要过的去，也要回得来</li>
</ul>
</li>
<li>The maximum strong connected subgraph (极大强连通子图) of a non-strongly connected graph is called strongly connected conponent (强连通分量).(一个非强连通图的最大强连通子图(South-South-PosialSuth-Posiple Fug)称为强连通构(Suth-Posiple Stand))</li>
</ol>
<h2 id="111-加权图network"><a class="markdownIt-Anchor" href="#111-加权图network"></a> 1.11. 加权图(Network)</h2>
<ol>
<li>When weights and costs are assigned to edges, the resulting data object is called weighted graph and weighted digraph.(当权值和代价分配给边时，得到的数据对象称为加权图和加权有向图。)</li>
<li>The term network refers to weighted  connected graph and weighted connected digraph. (网络是用来代指加权连通图和加权连通有向图)</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/7.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h2 id="112-生成树spanning-tree"><a class="markdownIt-Anchor" href="#112-生成树spanning-tree"></a> 1.12. 生成树(Spanning tree)</h2>
<ol>
<li>A spanning tree of a connected graph is its minimum connected subgraph(最小连通子图).  An n-vertex spanning tree has n-1 edges. (<strong>连通图的生成树是其最小连通子图。n顶点生成树有n-1条边。</strong>)
<ul>
<li>保持联通的最小边数的图</li>
</ul>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/8.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h1 id="2-adt-graph-and-digraph-无向图和无向图的抽象逻辑"><a class="markdownIt-Anchor" href="#2-adt-graph-and-digraph-无向图和无向图的抽象逻辑"></a> 2. ADT Graph and Digraph 无向图和无向图的抽象逻辑</h1>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">AbstractDataType Graph &#123;<br>    instances 实例<br>        a set V <span class="hljs-keyword">of</span> vertices <span class="hljs-keyword">and</span> a set E <span class="hljs-keyword">of</span> edges 顶点集合V 和 边集E<br>    operations 操作<br>        <span class="hljs-constructor">Create(<span class="hljs-params">n</span>)</span>:create an undirected graph <span class="hljs-keyword">with</span> n vertices <span class="hljs-keyword">and</span> no edges 创建一个n个顶点没有边的无向图<br>        <span class="hljs-constructor">Exist(<span class="hljs-params">i</span>,<span class="hljs-params">j</span>)</span>: return <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> edge(i,j)exists; <span class="hljs-literal">false</span> otherwise 当且仅当存在边i、j的时候返回<span class="hljs-literal">true</span><br>        <span class="hljs-constructor">Edges()</span>:return the number <span class="hljs-keyword">of</span> edges <span class="hljs-keyword">in</span> the graph 返回图的边的个数<br>        <span class="hljs-constructor">Vertices()</span>:return the number <span class="hljs-keyword">of</span> vertices <span class="hljs-keyword">in</span> the graph 返回图的顶点个数<br>        <span class="hljs-constructor">Add(<span class="hljs-params">i</span>,<span class="hljs-params">j</span>)</span>: add the edge(i,j) <span class="hljs-keyword">to</span> the graph 将i、j边添加到图中<br>        <span class="hljs-constructor">Delete(<span class="hljs-params">i</span>,<span class="hljs-params">j</span>)</span>:delete the edge (i,j) 删除边i、j <br>        <span class="hljs-constructor">Degree(<span class="hljs-params">i</span>)</span>: return the degree <span class="hljs-keyword">of</span> vertex i 返回顶点i的度数<br>        <span class="hljs-constructor">InDegree(<span class="hljs-params">i</span>)</span>: synonym <span class="hljs-keyword">for</span> degree 和度数相同<br>        <span class="hljs-constructor">OutDegree(<span class="hljs-params">i</span>)</span>: synonym <span class="hljs-keyword">for</span> degree 和度数相同&#125;<br></code></pre></td></tr></table></figure>
<h1 id="3-图的表示与实现representation-of-graphs-and-digraphs"><a class="markdownIt-Anchor" href="#3-图的表示与实现representation-of-graphs-and-digraphs"></a> 3. 图的表示与实现(Representation of graphs and digraphs)</h1>
<ol>
<li>有向图(graphs)</li>
<li>无向图(digraphs)</li>
</ol>
<h2 id="31-邻接矩阵adjacency-matrix"><a class="markdownIt-Anchor" href="#31-邻接矩阵adjacency-matrix"></a> 3.1. 邻接矩阵(Adjacency Matrix)</h2>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/10.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol>
<li>无向图的邻接矩阵</li>
<li><strong>无向图的每个顶点的度数等于矩阵中每一行的和</strong>。</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/11.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="2">
<li>有向图的邻接矩阵
<ul>
<li><strong>出度对行求和</strong></li>
<li><strong>入度对列求和</strong></li>
</ul>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/13.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="3">
<li>加权图(网络)的邻接矩阵
<ul>
<li>注意使用的无穷标识没有通路</li>
</ul>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/14.png" srcset="/project/img/loading.gif" lazyload alt="" /><br />
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/15.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="4">
<li>当节点数很大，边很少的时候不适用于邻接矩阵。</li>
</ol>
<h3 id="311-邻接矩阵性质"><a class="markdownIt-Anchor" href="#311-邻接矩阵性质"></a> 3.1.1. 邻接矩阵性质</h3>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/12.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol>
<li>无向图的邻接矩阵是对称的。</li>
</ol>
<h2 id="32-其他需要的结构"><a class="markdownIt-Anchor" href="#32-其他需要的结构"></a> 3.2. 其他需要的结构</h2>
<ol>
<li>一个记录各顶点信息的表</li>
<li>一个当前的边数</li>
</ol>
<h2 id="33-邻接矩阵实现的代码"><a class="markdownIt-Anchor" href="#33-邻接矩阵实现的代码"></a> 3.3. 邻接矩阵实现的代码</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MaxNumEdges = <span class="hljs-number">50</span><span class="hljs-comment">// 最大边数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MaxNumVertices = <span class="hljs-number">10</span><span class="hljs-comment">//最大顶点数 </span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> NameType, <span class="hljs-keyword">class</span> DistType&gt; <span class="hljs-keyword">class</span> Graph&#123;<br>    <span class="hljs-keyword">private</span>:<br>        SeqList&lt;NameType&gt; <span class="hljs-built_in">VerticesList</span>(MaxNumVertices) <span class="hljs-comment">//顶点表</span><br>        DistType Edge [MaxNumVertices] [MaxNumVertices]  <span class="hljs-comment">//邻接矩阵，一定是方阵</span><br>        <span class="hljs-type">int</span> CurrentEdges;<span class="hljs-comment">//当前边数</span><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FindVertex</span> <span class="hljs-params">(Seqlist &lt;NameType&gt; &amp;L; <span class="hljs-type">const</span>  NameType &amp;Vertex)</span></span><br><span class="hljs-function">            </span>&#123;<span class="hljs-keyword">return</span> L.<span class="hljs-built_in">Find</span>(Vertex);&#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetVertexPos</span> <span class="hljs-params">(<span class="hljs-type">const</span> NameTyoe &amp;Vertex)</span></span><br><span class="hljs-function">            </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">FindVertex</span>(VerticesList);&#125;<span class="hljs-comment">// 给出了顶点Vertex在图中的位置</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Graph</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> sz=MaxNumEdges); <br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GraphEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> VerticesList.<span class="hljs-built_in">IsEmpty</span>();&#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GraphFull</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> VerticesList.<span class="hljs-built_in">IsFull</span>() || CurrentEdges= =MaxNumEdges;&#125;<br><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NumberofVertices</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> VerticesList.last;&#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NumberofEdges</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> CurrentEdges;&#125;<br>        <span class="hljs-function">NameType <span class="hljs-title">Getvalue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i)</span> </span>&#123;<span class="hljs-keyword">return</span>  i&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;VerticesList.last ? VerticesList.data[i] :  <span class="hljs-literal">NULL</span>;&#125; <br>        <span class="hljs-function">DistType <span class="hljs-title">Getweight</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> v1,<span class="hljs-type">const</span> <span class="hljs-type">int</span> v2)</span></span>;<br>        <br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetFirstNeighbor</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> v)</span></span>; <br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetNextNeighbor</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> v1,<span class="hljs-type">const</span> <span class="hljs-type">int</span> v2)</span></span>;<br>        <br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertVertex</span><span class="hljs-params">(<span class="hljs-type">const</span> NameType &amp; Vertex)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertEdge</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> v1,<span class="hljs-type">const</span> <span class="hljs-type">int</span> v2, DistType weight)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeVertex</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> v)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeEdge</span><span class="hljs-params">(cosnt <span class="hljs-type">int</span> v1,<span class="hljs-type">const</span> <span class="hljs-type">int</span> v2)</span></span>;<br>&#125; <br></code></pre></td></tr></table></figure>
<h3 id="331-需要实现的方法"><a class="markdownIt-Anchor" href="#331-需要实现的方法"></a> 3.3.1. 需要实现的方法</h3>
<ol>
<li>构造方法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistType</span>&gt; Graph&lt;NameType, DistType&gt;::<span class="hljs-built_in">Graph</span>(<span class="hljs-type">int</span> sz) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;sz; j++)<br>            Edge [i][j]=<span class="hljs-number">0</span>;<br>    currentEdge=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//进行图结构的初始化</span><br>    <span class="hljs-comment">//边数组的默认初始化值均为0</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>求顶点V的第一个邻接顶点的位置</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistType</span>&gt; <span class="hljs-type">int</span> Graph&lt;NameType, DistType&gt;::<span class="hljs-built_in">GetFirstNeighbor</span>(<span class="hljs-type">int</span> v) &#123;<br>    <span class="hljs-keyword">if</span> (v!=<span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> col=<span class="hljs-number">0</span>; col&lt;CurrentVertices; col++)<br>            <span class="hljs-keyword">if</span> (Edge[v][col]&gt;<span class="hljs-number">0</span> &amp;&amp; Edge[v][col]&lt;max)<br>                <span class="hljs-keyword">return</span> col;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="34-邻接表实现"><a class="markdownIt-Anchor" href="#34-邻接表实现"></a> 3.4. 邻接表实现</h2>
<ol>
<li>reduce the storage requirement if the number of edges in the graph is small.当无向图中的边的个数比较少的时候，降低存储需要的空间的量</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/16.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="2">
<li>Eg.无向图的例子
<ul>
<li>cost是指权重</li>
</ul>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/17.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h3 id="341-邻接表的声明"><a class="markdownIt-Anchor" href="#341-邻接表的声明"></a> 3.4.1. 邻接表的声明</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//邻接表的声明</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Defaultsize = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>，<span class="hljs-keyword">class</span> <span class="hljs-title class_">DistType</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">DistType</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>       <span class="hljs-comment">//边的定义 &#123;</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &lt;NameType,DistType&gt;;<span class="hljs-comment">//友元函数</span><br>    <span class="hljs-type">int</span> dest;<span class="hljs-comment">//边的另一顶点在顶点表中的位置 </span><br>    DistType cost;<span class="hljs-comment">//边上的权</span><br>    Edge&lt;DistType&gt; *link;<span class="hljs-comment">//下一条边的链指针</span><br>    <span class="hljs-built_in">Edge</span>() &#123;&#125;<br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> D,DistType C):<span class="hljs-built_in">dest</span>(D),<span class="hljs-built_in">cost</span>(C),<span class="hljs-built_in">link</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;<br>    <span class="hljs-type">int</span> operate != (<span class="hljs-type">const</span> Edge&lt;DistType&gt; &amp;E) <span class="hljs-type">const</span> &#123;<span class="hljs-keyword">return</span> dest != E.dest; &#125;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistType</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertex</span> &#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span>&lt;DistType&gt;;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span>&lt;NameType, DistType&gt;; <br>    NameType data;<span class="hljs-comment">//顶点名字</span><br>    Edge&lt;DistType&gt; *adj;<span class="hljs-comment">//出边表头指针</span><br>&#125; <br></code></pre></td></tr></table></figure>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/18.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h3 id="342-图的类定义"><a class="markdownIt-Anchor" href="#342-图的类定义"></a> 3.4.2. 图的类定义</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//图的类定义</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>，<span class="hljs-keyword">class</span> <span class="hljs-title class_">DistType</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        Vertex&lt;NameType, DistType&gt; *NodeTable; <span class="hljs-comment">//顶点表</span><br>        <span class="hljs-type">int</span> NumVertices;<span class="hljs-comment">//当前顶点数</span><br>        <span class="hljs-type">int</span> MaxNumVertices;<span class="hljs-comment">//最大顶点个数</span><br>        <span class="hljs-type">int</span> NumEdges;<span class="hljs-comment">//当前边数</span><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetVertexpos</span><span class="hljs-params">(<span class="hljs-type">const</span> Type &amp;Vertex)</span></span>;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Graph</span>(<span class="hljs-type">int</span> sz);<br>        ~<span class="hljs-built_in">Graph</span>();<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GraphEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> NumVertices= =<span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GraphFull</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> NumVertices= =MaxNumVertices;&#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NumberOfVertices</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> NumVertices;&#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NumberOfEdges</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> NumEdges;&#125;<br>        <span class="hljs-function">NameType <span class="hljs-title">GetValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i)</span> </span>&#123;<span class="hljs-keyword">return</span> i&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;NumVertices ? NodeTable[i].data: <span class="hljs-literal">NULL</span>;&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertVertex</span><span class="hljs-params">(<span class="hljs-type">const</span> NameType &amp;Vertex)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RemoveVertex</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> v2,DistType weight)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RemoveEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> v2)</span></span>; <br>        <span class="hljs-function">DistType <span class="hljs-title">Getweight</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> v2)</span></span>; <br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetFristNeighbor</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetNextNeighbor</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> v2)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="343-部分实现的方法"><a class="markdownIt-Anchor" href="#343-部分实现的方法"></a> 3.4.3. 部分实现的方法</h3>
<ol>
<li>构造方法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">DistType</span>&gt; Graph&lt;NameType,DistType&gt;::<span class="hljs-built_in">Graph</span>(<span class="hljs-type">int</span> sz=Defaultsize):<span class="hljs-built_in">NumVertices</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">MaxNumVertices</span>(sz),<span class="hljs-built_in">NumEdge</span>(<span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-type">int</span> NumVertices, NumEdges, k, j; <br>    NameType name,tail,head;<br>    DistType weight; <br>    NodeTable=newVertex&lt;NameType&gt;[MaxNumVertices]<br>    <br>    cin &gt;&gt; NumVertices;<span class="hljs-comment">//输入顶点数</span><br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;NumVertices; i++ ) &#123;  <br>        cin &gt;&gt; name;<br>        <span class="hljs-built_in">InsertVertex</span>(name);<br>    &#125;<br>    cin &gt;&gt; NumEdges;<span class="hljs-comment">//输入边数</span><br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;NumEdges; i++) &#123; <br>        cin &gt;&gt; tail &gt;&gt; head &gt;&gt; weight; <br>        k=<span class="hljs-built_in">GetVertexpos</span>(tail);<br>        j=<span class="hljs-built_in">GetVertexpos</span>(head);<br>        <span class="hljs-built_in">InsertEdge</span>(k,j,weight);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>根据数据值找到下标</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> Graph&lt;NameType,DistType&gt;::<span class="hljs-built_in">GetVertexpos</span>(<span class="hljs-type">const</span> NameType &amp;Vertex) &#123;<br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;NumVertices; i++)<br>        <span class="hljs-keyword">if</span> (NodeTable[i].data == Vertex)<br>            <span class="hljs-keyword">return</span> i;<br>    <span class="hljs-keyword">return</span> –<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="3">
<li>给出顶点V的第一个邻接顶点的位置</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">DistType</span>&gt; <span class="hljs-type">int</span> Graph&lt;NameType,DistType&gt;::<span class="hljs-built_in">GetFirstNeighbor</span>(<span class="hljs-type">int</span> v) &#123;<br>    <span class="hljs-keyword">if</span> (v!=<span class="hljs-number">-1</span>) &#123;<br>        Edge&lt;DistType&gt;* p=NodeTable[v].adj; <br>        <span class="hljs-keyword">if</span> (p!=<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> p-&gt;dest;<br>    &#125;<br>    <span class="hljs-keyword">return</span> –<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="4">
<li>找到下一个邻居</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">DistType</span>&gt; <span class="hljs-type">int</span> Graph&lt;NameType,DistType&gt;::<span class="hljs-built_in">GetNextNeighbor</span> (<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> v2) &#123;<br>    <span class="hljs-keyword">if</span> (v1!=<span class="hljs-number">-1</span>) &#123;<br>        Edge&lt;DistType&gt; *p=NodeTable[v1].adj; <br>        <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span>(p-&gt;dest==v2 &amp;&amp; p-&gt;link!=<span class="hljs-literal">NULL</span>)<br>                <span class="hljs-keyword">return</span> p-&gt;link-&gt;dest;<br>            <span class="hljs-keyword">else</span> p=p-&gt;link;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> –<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="35-邻接多重表"><a class="markdownIt-Anchor" href="#35-邻接多重表"></a> 3.5. 邻接多重表</h2>
<ol>
<li>在无向图中, 如果边数为m, 则在邻接表表示中需2m个单位来存储. 为了克服这一缺点, 采用邻接多重表, 每条边用一个结点表示.
<ul>
<li>其中的两个结点号就是边的两个点。</li>
<li>path1指向的就是同样始点(vertex1)，顺序终点的结果。</li>
<li>path2执行的是以vertex2为始点顺序向下的。</li>
</ul>
</li>
<li>Eg.使用正常的邻接表，则右边应该有10个点，但是多种表就是只有5个表
<ul>
<li>默认情况下边的始点的编号要小于终点的编号大小。</li>
</ul>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/19.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="3">
<li>对有向图而言，需用邻接表和逆邻接表，如果把这两个表结合起来用有向图的邻接多重表(也称为十字链表)来表示一个有向图.</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/20.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="4">
<li>邻接表和邻接多重表之间的区别在于有几个顶点，有几个边。</li>
<li>data部分只记录first-in和first-out，也就是第一条出边和第一条入边。</li>
</ol>
<h1 id="4-图的遍历和连通性"><a class="markdownIt-Anchor" href="#4-图的遍历和连通性"></a> 4. 图的遍历和连通性</h1>
<ol>
<li>图的遍历 (Graph Traversal): 从图中某一顶点出发访问图中其余顶点,且使每个顶点<strong>仅</strong>被访问一次.</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/21.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="2">
<li>树的遍历，左子女右兄弟。</li>
</ol>
<h2 id="41-dfsdepth-first-search深度优先搜索"><a class="markdownIt-Anchor" href="#41-dfsdepth-first-search深度优先搜索"></a> 4.1. DFS(depth-first-search,深度优先搜索)</h2>
<h3 id="411-算法思想"><a class="markdownIt-Anchor" href="#411-算法思想"></a> 4.1.1. 算法思想</h3>
<ol>
<li>从图中某个顶点V0出发,访问它,然后选择一个<br />
V0邻接到的未被访问的一个邻接点V1出发深度优先遍<br />
历图,当遇到一个所有邻接于它的结点都被访问过了的<br />
结点U时,回退到前一次刚被访问过的拥有未被访问的<br />
邻接点W,再从W出发深度遍历,……直到连通图中的所<br />
有顶点都被访问过为止.</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/22.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="2">
<li>递归方法实现 算法中用一个辅助数组visited[]:
<ol>
<li>0:未访问</li>
<li>1:访问过了</li>
<li>我们假设图为连通图</li>
</ol>
</li>
</ol>
<h3 id="412-算法实现"><a class="markdownIt-Anchor" href="#412-算法实现"></a> 4.1.2. 算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//利用的是邻接矩阵来表示的图</span><br><span class="hljs-comment">//主过程:</span><br><span class="hljs-keyword">template</span>&lt;NameType,DistType&gt; <span class="hljs-type">void</span> Graph&lt;NameType,DistType&gt;::<span class="hljs-built_in">DFS</span>( ) &#123;<br>    <span class="hljs-type">int</span> *visited=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[NumVertices];<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;NumVertices; i++)<br>        visited[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">DFS</span>(<span class="hljs-number">0</span>,visited);<span class="hljs-comment">//从顶点0开始深度优先搜索</span><br>        <span class="hljs-keyword">delete</span>[] visited;<span class="hljs-comment">//释放visited的空间</span><br>    &#125;<br><span class="hljs-comment">//子过程</span><br><span class="hljs-keyword">template</span>&lt;NameType,DistType&gt; <span class="hljs-type">void</span> Graph&lt;NameType,DistType&gt;::<span class="hljs-built_in">DFS</span>(<span class="hljs-type">int</span> v, visited[]) &#123;<br>    cout&lt;&lt;<span class="hljs-built_in">GetValue</span>(v)&lt;&lt;<span class="hljs-string">&quot;&quot;</span>;<br>    visited[v]=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> w = <span class="hljs-built_in">GetFirstNeighbor</span>(v);<br>    <span class="hljs-keyword">while</span> (w!=<span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">if</span>(!visited[w])<br>            <span class="hljs-built_in">DFS</span>(w,visited);<span class="hljs-comment">//最坏情况，就是每一次w都没有被访问过</span><br>        w = <span class="hljs-built_in">GetNextNeighbor</span>(v,w);<br>    &#125;<br>    <span class="hljs-comment">//无论如何，最坏情况下访问次数，也就只能是图中所有边的个数。</span><br>    <span class="hljs-comment">//也就是对邻接矩阵所有边会被扫一遍</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="413-算法分析"><a class="markdownIt-Anchor" href="#413-算法分析"></a> 4.1.3. 算法分析</h3>
<ol>
<li>用邻接表表示 O(n+e)</li>
<li>用邻接矩阵表示 O(n<sup>2</sup>)</li>
</ol>
<h2 id="42-广度优先搜索breadth-search"><a class="markdownIt-Anchor" href="#42-广度优先搜索breadth-search"></a> 4.2. 广度优先搜索(Breadth search)</h2>
<h3 id="421-思想"><a class="markdownIt-Anchor" href="#421-思想"></a> 4.2.1. 思想</h3>
<ol>
<li>从图中某顶点V0出发，在访问了V0之后依次访<br />
问v0的各个未曾访问过的邻接点，然后分别从这些邻接<br />
点出发广度优先遍历图，直至图中所有顶点都被访问<br />
到为止.</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/23.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="2">
<li>算法同样需要一个辅助数组visited[] 表示顶点是否被访问过. 还需要一个队列,记正在访问的这一层和上一层的顶点. 算法显然是非递归的.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;NameType,DistType&gt; <span class="hljs-type">void</span> Graph&lt;NameType,DistType&gt;::<span class="hljs-built_in">BFS</span>(<span class="hljs-type">int</span> v) &#123;<br>    <span class="hljs-comment">//这个算法使用了队列</span><br>    <span class="hljs-type">int</span>* visited=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[NumVertices];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;NumVertices; i++)<br>        visited[i]=<span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">GetValue</span>(v) &lt;&lt; <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">//访问结点</span><br>    visited[v]=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//使用队列来存储顶点</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">EnQueue</span>(v);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">IsEmpty</span>()) &#123;<br>        v= q.<span class="hljs-built_in">DeQueue</span>();<br>        <span class="hljs-type">int</span> w= <span class="hljs-built_in">GetFirstNeighbor</span>(v);<br>        <span class="hljs-keyword">while</span> (w!=<span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">if</span>(!visited[w]) &#123;<br>                cout&lt;&lt;<span class="hljs-built_in">GetValue</span>(w)&lt;&lt;<span class="hljs-string">&quot;&quot;</span>; <br>                visited[w]=<span class="hljs-number">1</span>;<br>                q.<span class="hljs-built_in">EnQueue</span>(w);<br>            &#125;<br>            w= <span class="hljs-built_in">GetNextNeighbor</span>(v,w);<br>            <span class="hljs-comment">//访问完成一层的结点</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] visited;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="422-算法分析"><a class="markdownIt-Anchor" href="#422-算法分析"></a> 4.2.2. 算法分析</h3>
<ol>
<li>每个顶点进队列一次且只进一次，∴算法中循环语句至多执行n次。</li>
<li>从具体图的存储结构来看
<ol>
<li>如果用邻接表：O(n+e)</li>
<li>如果用邻接矩阵: 对每个被访问过的顶点，循环检测矩阵中n个元素，∴时间代价为 O(n<sup>2</sup>)</li>
</ol>
</li>
</ol>
<h2 id="43-连通分量"><a class="markdownIt-Anchor" href="#43-连通分量"></a> 4.3. 连通分量</h2>
<ol>
<li>以上讨论的是对一个无向的连通图或一个强连通图的有向图进行遍历，得到一棵深度优先或广度优先生成树.<br />
但当无向图(以无向图为例)为非连通图时，从图的某一<br />
顶点出发进行遍历(深度，广度)只能访问到该顶点所在<br />
的最大连通子图(即连通分量)的所有顶点.</li>
<li>下面是利用深度优先搜索求非连通图的连通分量算法 实际上只要加一个循环语句就行了.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">Template&lt;NameType,DistType&gt; <span class="hljs-type">void</span> Graph&lt;NameType,DistType&gt; :: <span class="hljs-built_in">components</span>() &#123;  <br>    <span class="hljs-type">int</span>* visited = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[NumVertices];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;NumVertices;i++)<br>        visited[i]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;NumVertices; i++)<br>        <span class="hljs-comment">//只需要对于每一个顶点进行操作即可</span><br>        <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>            <span class="hljs-built_in">DFS</span>(i,visited);<br>            <span class="hljs-built_in">outputNewComponent</span>();<br>        &#125;<br>        <span class="hljs-keyword">delete</span>[] visited;<br>&#125;     <br></code></pre></td></tr></table></figure>
<h1 id="5-最小生成树"><a class="markdownIt-Anchor" href="#5-最小生成树"></a> 5. 最小生成树</h1>
<h2 id="51-生成树"><a class="markdownIt-Anchor" href="#51-生成树"></a> 5.1. 生成树</h2>
<h3 id="511-生成树的定义"><a class="markdownIt-Anchor" href="#511-生成树的定义"></a> 5.1.1. 生成树的定义</h3>
<ol>
<li>设G =(V，E)是一个连通的无向图(或是强连通有向图) 从图G中的任一顶点出发作遍历图的操作，把遍历走过的边的集合记为TE(G)，显然 G‘=(V，TE)是G之子图， G‘被称为G的生成树(spanning tree)，也称为一个连通图.</li>
<li>n个结点的生成树有n-1条边。</li>
<li>生成树的代价(cost)：TE(G)上诸边的代价之和</li>
<li>生成树不唯一</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/24.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h3 id="512-最小代价生成树"><a class="markdownIt-Anchor" href="#512-最小代价生成树"></a> 5.1.2. 最小代价生成树</h3>
<ol>
<li>各边权的<strong>总和</strong>为最小的生成树</li>
</ol>
<h2 id="52-贪心grandy求解最小代价生成树"><a class="markdownIt-Anchor" href="#52-贪心grandy求解最小代价生成树"></a> 5.2. 贪心(Grandy)求解最小代价生成树</h2>
<ol>
<li>6个城市已固定，现从一个城市发出信息到每一个城市如何选择或铺设通信线路，使花费(造价)最低。</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/25.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/26.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="2">
<li>两个算法：Prim, Kruskal.</li>
<li>算法思想:贪心算法(逐步求解)</li>
</ol>
<h3 id="521-贪心策略的具体内容"><a class="markdownIt-Anchor" href="#521-贪心策略的具体内容"></a> 5.2.1. 贪心策略的具体内容</h3>
<ol>
<li>Grandy策略：设：连通网络N={V,E}, V中有n个顶点。
<ol>
<li>先构造 n 个顶点，0 条边的森林 F ={T0,T1,……,Tn-1}</li>
<li>每次向 F 中加入一条边。该边是一端在 F 的某棵树Ti上而另一端不在Ti上的所有边中具有最小权值的边。 这样使F中两棵树合并为一棵，树的棵数 - 1</li>
<li>重复上述操作n-1次</li>
</ol>
</li>
<li>去掉所有边，每次加入的边是当前最小的边，并且保证这个边不是回边。</li>
</ol>
<h3 id="522-最小生成树的类声明"><a class="markdownIt-Anchor" href="#522-最小生成树的类声明"></a> 5.2.2. 最小生成树的类声明</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXINT = 机器可表示的，问题中不可能出现的大数<br><span class="hljs-keyword">class</span> MinSpanTree;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MSTEdgeNode</span> &#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinSpanTree</span>;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> tail ,head;<br>        <span class="hljs-type">int</span> cost;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ol>
<li>边结构:tail + head + cost</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinSpanTree</span> &#123;<br>    <span class="hljs-keyword">public</span> : <span class="hljs-built_in">MinSpanTree</span>(<span class="hljs-type">int</span> SZ = NumVertices<span class="hljs-number">-1</span>):<br>        <span class="hljs-built_in">MaxSize</span>(SZ), <span class="hljs-built_in">n</span>(<span class="hljs-number">0</span>)&#123;edgevalue = <span class="hljs-keyword">new</span> MSTEdgeNode[MaxSize];&#125; <br>    <span class="hljs-keyword">protected</span>:<br>        MSTEdgeNode* edgevalue;<span class="hljs-comment">//边值数组</span><br>        <span class="hljs-type">int</span> MaxSize, n;<span class="hljs-comment">//数组的最大元素个数和 //当前个数</span><br>&#125;；<br></code></pre></td></tr></table></figure>
<h2 id="53-kruskal算法对边进行排序然后生成"><a class="markdownIt-Anchor" href="#53-kruskal算法对边进行排序然后生成"></a> 5.3. Kruskal算法(对边进行排序，然后生成)</h2>
<ol>
<li>把无向图的所有边排序</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/27.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="2">
<li>一开始的最小生成树为</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/28.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="3">
<li>在E中选一条代价最小的边(u,v)加入T，一定要满足(u,v) 不和TE中已有的边构成回路</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/29.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="4">
<li>一直到TE中加满n-1条边为止。</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/30.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h3 id="531-代码实现"><a class="markdownIt-Anchor" href="#531-代码实现"></a> 5.3.1. 代码实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">void</span> Graph&lt;string,<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">Kruskal</span>(MinSpanTree&amp;T) &#123;<br>    <span class="hljs-comment">//结果赋值给T</span><br>    MSTEdgeNode e;<br>    MinHeap&lt;MSTEdgeNode&gt;<span class="hljs-built_in">H</span>(currentEdges);<br>    <span class="hljs-type">int</span> NumVertices=VerticesList.Last , u , v ;<br>    <span class="hljs-function">Ufsets <span class="hljs-title">F</span><span class="hljs-params">(NumVertices)</span></span>;<span class="hljs-comment">//建立n个单元素的连通分量</span><br>    <span class="hljs-keyword">for</span>(u=<span class="hljs-number">0</span>;u&lt;NumVertices;u++)<br>        <span class="hljs-keyword">for</span> (v=u+<span class="hljs-number">1</span>;v&lt;NumVertices;v++)<br>            <span class="hljs-keyword">if</span>(Edge[u][v]!=MAXINT) &#123;<br>                e.tail=u;<br>                e.head=v;<br>                e.cost=Edge[u][v];<br>                H.<span class="hljs-built_in">insert</span>(e);<br>                <span class="hljs-comment">//完成堆的初始化，将每一条边插入到优先级队列中去</span><br>            &#125;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">1</span>;<span class="hljs-comment">//生成树边计数</span><br>    <span class="hljs-keyword">while</span>(count&lt;NumVertices) &#123;<br>        H.<span class="hljs-built_in">RemoveMin</span>(e);<br>        u=F.<span class="hljs-built_in">Find</span>(e.tail);<span class="hljs-comment">//找到并查集的树根</span><br>        v=F.<span class="hljs-built_in">Find</span>(e.head);<span class="hljs-comment">//找到并查集的树根</span><br>        <span class="hljs-keyword">if</span>(u!=v)&#123;<br>            <span class="hljs-comment">//并查集做回边检测，在同一个并查集中就是一个回边，不然就不是</span><br>            F.<span class="hljs-built_in">union</span>(u,v);<br>            T.<span class="hljs-built_in">Insert</span>(e);<br>            count++;<span class="hljs-comment">//计数已经查找出来的个数</span><br>        &#125;<br>        <span class="hljs-comment">//最坏的情况时所有的边都被访问一次，比如目标边是最后一条边。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">kruskal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> edgesAccepted;<br>    DisjSet s;<br>    priorityQueue h;<br>    Vertex u, v;<br>    SetType uset, vset;<br>    Edge e;<br>    h = readGraphIntoHeapArray( );<br>    h.buildHeap() ;<br>    s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisjSet</span>( NUM_VERTICES );<br><br>    edgesAccepted = <span class="hljs-number">0</span> ;<br>    <span class="hljs-keyword">while</span>( edgesAccepted &lt; NUM_VERTICES – <span class="hljs-number">1</span> )&#123;<br>        e = h.deleteMin() ;<span class="hljs-comment">//Edge e = (u, v)</span><br>        uset = s. find(u);<br>        vset = s.find(v);<br>        <span class="hljs-keyword">if</span>( uset != vset ) &#123;<br>            edgesAccepted++;<br>            s.union( uset, vset );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="532-算法分析"><a class="markdownIt-Anchor" href="#532-算法分析"></a> 5.3.2. 算法分析</h3>
<ol>
<li>建立<strong>e</strong>条边的最小堆
<ol>
<li>检测邻接矩阵O(n<sup>2</sup>)</li>
<li>每插入一条边，执行一次 fiterup() 算法：log<sub>2</sub>e 所以，总的建堆时间为O(elog<sub>2</sub>e)</li>
</ol>
</li>
<li>构造最小生成树时
<ol>
<li>e次出堆操作：每一次出堆，执行一次filterdown(), 总时间为O(elog2e)
<ul>
<li>没有考虑悬挂问题</li>
</ul>
</li>
<li>2e次find操作：O(elog<sub>2</sub>n)，树高是log2n
<ul>
<li>从头开始生成，两个高为1的树，做union，才有高度为2的树</li>
<li>两个高为2的树，做union，才有高度为3的树</li>
<li>树的高度最坏情况下是log<sub>2</sub>n，当切仅当第一个二叉树</li>
</ul>
</li>
<li>n-1次union操作：O(n)</li>
<li>所以，总的计算时间为O(elog<sub>2</sub>e+elog<sub>2</sub>n+n<sup>2</sup>+n)</li>
</ol>
</li>
</ol>
<h2 id="54-物理实现"><a class="markdownIt-Anchor" href="#54-物理实现"></a> 5.4. 物理实现</h2>
<ol>
<li>图用<strong>邻接矩阵</strong>表示，edge(边的信息)</li>
<li>图的顶点信息在顶点表 Verticelist中</li>
<li>边的条数为CurrentEdges</li>
<li>取最小的边以及判别是否构成回路，</li>
<li>取最小的边利用:最小堆(MinHeap)</li>
</ol>
<h2 id="55-prim算法结合顶点考虑所有可达的边的权重大小"><a class="markdownIt-Anchor" href="#55-prim算法结合顶点考虑所有可达的边的权重大小"></a> 5.5. Prim算法(结合顶点，考虑所有可达的边的权重大小)</h2>
<ol>
<li>设：原图的顶点集合V(有n个)生成树的顶点集合U(最后也有n个)，一开始为空TE集合为{}</li>
<li>步骤：
<ol>
<li>U={1}任何起始顶点，TE={}</li>
<li>每次生成(选择)一条边。这条边是所有边(u,v) 中代价(权)最小的边， u∈U,v∈V-U TE=TE+[(u,v)]; U=U+[v]</li>
<li>当U≠V，返回上面一个步骤</li>
</ol>
</li>
</ol>
<h3 id="551-例子"><a class="markdownIt-Anchor" href="#551-例子"></a> 5.5.1. 例子</h3>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/31.png" srcset="/project/img/loading.gif" lazyload alt="" /><br />
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/32.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol>
<li>一开始只考虑从1号顶点到其他顶点之间的边。
<ul>
<li>泛泛而言，考虑u和v之间的边</li>
</ul>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/33.png" srcset="/project/img/loading.gif" lazyload alt="" /><br />
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/34.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h3 id="552-最小生成树不唯一"><a class="markdownIt-Anchor" href="#552-最小生成树不唯一"></a> 5.5.2. 最小生成树不唯一</h3>
<ol>
<li>对于一般的图来讲，最小生成树不唯一。</li>
<li>所以相应的Prime算法和Kruskal算法也会出现多解得 情况。</li>
</ol>
<h3 id="553-算法分析"><a class="markdownIt-Anchor" href="#553-算法分析"></a> 5.5.3. 算法分析</h3>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/35.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol>
<li>第一次的时候u只有1个元素，而第二次则有2个，以此类推。</li>
<li>使用邻接矩阵实现的图，可以把时间复杂度降低到O(n<sup>2</sup>)</li>
</ol>
<h2 id="56-prim算法优化"><a class="markdownIt-Anchor" href="#56-prim算法优化"></a> 5.6. Prim算法优化</h2>
<ol>
<li>使用两个数组Lowcost[ ]、nearvex[ ]</li>
<li>Lowcost[]:存放生成树顶点集合内顶点到生成树外各顶点的边上的当前最小权值</li>
<li>nearvex[]:记录生成树顶点集合外各顶点，距离集合内那个顶点最近。</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/36.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="4">
<li>
<p>拿u为1364为例，将2拉入u之后，如果1364到5的最小值小于2到5之间的距离，则抛弃25边，否则更新数组。<br />
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/37.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
</li>
<li>
<p>对于nearvex:记录的结点，lowcost对应记录的是相应边的权重(按照上面的序号)</p>
<ul>
<li>更新最小边:发生在加入新的结点的时候，需要在nearvex中更新对应位置的最小边。</li>
</ul>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/36.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h3 id="561-算法实现"><a class="markdownIt-Anchor" href="#561-算法实现"></a> 5.6.1. 算法实现</h3>
<ol>
<li>在Lowcost[ ]中选择nearvex[i]不等于-1,且lowcost[i] 最小的边用v标记它。，则选中的权值最小的边为(nearvex[v],v), 相应的权值为lowcost[v]。 例如在上面图中第一次选中的v=5;则边(0，5)，是选中的权值最小的边，相应的权值为lowcost[5]=10。 反复做以下工作</li>
<li>将nearvex[v] 改为-1，表示它已加入生成树顶点集合。将边(nearvex[v],v,lowcost[v])加入生成树的边集合。</li>
<li>修改。取lowcost[i]=min{lowcost[i],Edge[v][i]},即用生成树顶点集合外各顶 点i到刚加入该集合的新顶点 v的距离(Edge[v][i])与原来它所到生成树顶点 集合中顶点的最短距离lowcost[i]做比较，取距离近的，作为这些集合外顶 点到生成树顶点集合内顶点的最短距离。</li>
<li>如果生成树顶点集合外的顶点i到刚加入该集合新顶点v的距离比原来它 到生成树顶点集合中顶点的最短距离还要近，则修改nearvex[i]: nearvex[i]=v 表示生成树外顶点i到生成树的内顶点v 当前距离最短。</li>
</ol>
<h3 id="562-示例"><a class="markdownIt-Anchor" href="#562-示例"></a> 5.6.2. 示例</h3>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/38.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol>
<li>4-&gt;5 25&lt;正无穷，更新
<ul>
<li>nearvex更新顶点，lowcost更新权值</li>
</ul>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/39.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol>
<li>考虑1-&gt;4、2-&gt;4等等</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/40.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/41.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/42.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/43.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h3 id="563-prim算法实现"><a class="markdownIt-Anchor" href="#563-prim算法实现"></a> 5.6.3. Prim算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">void</span> graph&lt;string,<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">Prim</span>(MinSpanTree&amp;T)&#123;<br>    <span class="hljs-type">int</span> NumVertices=VerticesList.last; <br>    <span class="hljs-type">float</span>*lowcost=<span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[NumVertices]; <br>    <span class="hljs-type">int</span> * nearvex=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[NumVertices];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt; NumVertices;i++) &#123;<br>        lowcost[i] = Edge[<span class="hljs-number">0</span>][i];<span class="hljs-comment">//0到其他所有边的权值</span><br>        nearvex[i]=<span class="hljs-number">0</span>;<br>    &#125;<br>    nearvex[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<br>    MSTEdgeNode e;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt; NumVertices; i++) &#123;<br>        <span class="hljs-type">float</span> min=MAXINT;<br>        <span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt; NumVertices; j++)<br>            <span class="hljs-keyword">if</span>(nearvex[j]!=<span class="hljs-number">-1</span>&amp;&amp;lowcost[j]&lt;min) &#123;<br>                v=j;<br>                min=lowcost[j];<br>            &#125; <span class="hljs-comment">//for j,  选择最小的边</span><br><br>        <span class="hljs-keyword">if</span>(v) &#123;<br>            e.tail=nearvex[v];<br>            e.head=v;<br>            e.cost=lowcost[v];<br>            T.<span class="hljs-built_in">Insert</span>(e);<br>            <span class="hljs-comment">//添加边进入最小生成树中去</span><br>            nearvex[v]=<span class="hljs-number">-1</span>;<br>            <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt; NumVertices; j++)<br>                <span class="hljs-keyword">if</span>( nearvex[j]!=<span class="hljs-number">-1</span> &amp;&amp; Edge[v][j]&lt;lowcost[j] ) &#123;<br>                    lowcost[j]=Edge[v][j];<br>                    nearvex[j]=v;<br>                &#125;<br>        &#125; <span class="hljs-comment">//if</span><br>    &#125; <span class="hljs-comment">//for i</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="564-估计算法复杂度"><a class="markdownIt-Anchor" href="#564-估计算法复杂度"></a> 5.6.4. 估计算法复杂度</h3>
<ol>
<li>第一个for循环的复杂度是O(n)的</li>
<li>第二个嵌套的for循环的复杂度是O(n<sup>2</sup>)的</li>
</ol>
<h1 id="6-最短路径"><a class="markdownIt-Anchor" href="#6-最短路径"></a> 6. 最短路径</h1>
<ol>
<li>设G=(V,E)是一个带权图(有向，无向)，如果从顶点v到顶点w的一条路径为(v,v1,v2,…,w)，其路径长度不大于从v到w的所有其它路径的长度，则该路径为从 v 到 w 的最短路径。</li>
<li>背景:在交通网络中，求各城镇间的最短路径。</li>
<li>三种算法:
<ol>
<li>边上权值为非负情况的从一个结点到其它各结点的最短路径 (单源最短路径)(Dijkstra算法)</li>
<li>边上权值为任意值的单源最短路径</li>
<li>边上权值为非负情况的所有顶点之间的最短路径</li>
</ol>
</li>
</ol>
<h2 id="61-含非负权值的单源最短路径dijkstra"><a class="markdownIt-Anchor" href="#61-含非负权值的单源最短路径dijkstra"></a> 6.1. 含非负权值的单源最短路径(Dijkstra)</h2>
<ol>
<li>问题</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/44.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h3 id="611-贪心思想"><a class="markdownIt-Anchor" href="#611-贪心思想"></a> 6.1.1. 贪心思想</h3>
<ol>
<li>起点V0，首先直接连接，不管是否直接连接。</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/61.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="2">
<li>排好序后，V0-V1 10已经是最小的了，不可能再找到更短的路径</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/62.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="3">
<li>接下来，尝试V0-v2通过V1绕会不会比原来的更短(考虑V1-V2直连)，V0-V4从V1绕会不会比原来更短(考虑V2-V3直连)，如果短则更新，此时V0-V3是三者中最小值，所以选择V0-V3。</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/63.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="4">
<li>尝试绕行V3，计算直连，更新掉，然后重复</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/64.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="5">
<li>红色是已经选择好的，绿色是绕行选择。</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/65.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="6">
<li>进一步思考，就是只进行一步，不进行多不步。</li>
<li>总体来讲:不可能走更长的路径，然后回来</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/45.png" srcset="/project/img/loading.gif" lazyload alt="" /><br />
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/46.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="8">
<li>数值更新，路径数组对应位置更新</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/47.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h3 id="612-代码实现"><a class="markdownIt-Anchor" href="#612-代码实现"></a> 6.1.2. 代码实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> NumVertices = <span class="hljs-number">6</span>;<span class="hljs-comment">//大于所有边的权重的值</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">graph</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> Edge[NumVertices][NumVertices]; <br>        <span class="hljs-type">int</span> dist[NumVertices];<br>        <span class="hljs-type">int</span> path[NumVertices];<br>        <span class="hljs-type">int</span> S[NumVertices];<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shortestpath</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span></span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Graph::shortestpath</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> v)</span> </span>&#123;  <br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-comment">//v为当前节点，dist数组是表示距离的数组</span><br>        <span class="hljs-comment">//遍历n次</span><br>        dist[i] = Edge[v][i];<br>        s[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>( i!=v &amp;&amp; dist[i]&lt; MAXNUM )<br>            path[i]= v;<span class="hljs-comment">//如果可达，则用path数组记录下路径</span><br>        <span class="hljs-keyword">else</span><br>            path[i]=<span class="hljs-number">-1</span>;<span class="hljs-comment">//如果不可达，则用path数组记录下不可达(-1)</span><br>        &#125;<br>        s[v]=<span class="hljs-number">1</span>;<br>        dist[v]=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//表示访问过当前节点，并且距离为0</span><br>        <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;n<span class="hljs-number">-1</span>; i++) &#123;<br>            <span class="hljs-type">float</span> min=MAXNUM;<br>            <span class="hljs-type">int</span> u = v;<br>            <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;  j &lt; n;  j++)<br>                <span class="hljs-keyword">if</span>( !s[j] &amp;&amp; dist[j]&lt;min ) &#123;<br>                    <span class="hljs-comment">//如果结点j还没有访问过，并且dist[j]小于最小值</span><br>                    u = j;<br>                    min = dist[j];<br>                &#125;<br>            s[u]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> w=<span class="hljs-number">0</span>; w&lt;n; w++)<br>                <span class="hljs-keyword">if</span>( !s[w] &amp;&amp; Edge[u][w] &lt; MAXNUM &amp;&amp; dist[u]+Edge[u][w] &lt; dist[w]) &#123;<br>                    <span class="hljs-comment">//dist[u]就是起点到u的距离，下面是关键条件</span><br>                    dist[w]=dist[u]+Edge[u][w];<br>                    path[w]=u;<br>                &#125;<br>        &#125;<span class="hljs-comment">//for</span><br>&#125;   <br></code></pre></td></tr></table></figure>
<h3 id="613-算法复杂度分析"><a class="markdownIt-Anchor" href="#613-算法复杂度分析"></a> 6.1.3. 算法复杂度分析</h3>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/48.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h2 id="62-贝尔曼福特改进算法"><a class="markdownIt-Anchor" href="#62-贝尔曼福特改进算法"></a> 6.2. 贝尔曼——福特改进算法</h2>
<ol>
<li>边上权值为任意值的单源最短路径(贝尔曼—福特) dijkstra算法在边上权值为任意值的图上是不能正常工作的。</li>
<li>dist<sup>1</sup>[u],dist<sup>2</sup>[u],…dist<sup>n-1</sup>[u]
<ul>
<li>dist<sup>1</sup>[u]:是从源点v到终点u的只经过一条边的 的最短路径长度</li>
<li>dist<sup>1</sup>[u]=Edge[v][u]</li>
<li>dist<sup>2</sup>[u]:是从源点v最多经过两条边到达终点u 的最短路径长度；</li>
</ul>
</li>
<li>不允许出现负值回路出现</li>
<li>递推公式:
<ol>
<li>dist<sup>1</sup>[u]=Edge[v][u];</li>
<li>dist<sup>k</sup>[u]=min{dist<sup>k-1</sup> [u],min{dist<sup>k-1</sup>[j]+Edge[j][u]}} j=0,1,2,…,n-1</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/49.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="5">
<li>更新的时候都是根据前面结果，遍历计算存储</li>
<li>所有第k步，只受第k-1步的影响</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">Graph::BellmanFord</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-comment">//动态规划</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>        <span class="hljs-comment">//初始化dist距离数组</span><br>        dist[i]=Edge[v][i];<br>        <span class="hljs-keyword">if</span>(i!=v &amp;&amp; dist[i]&lt;MAXNUM) path[i]=v;<br>        <span class="hljs-comment">//初始化路径数组 </span><br>        <span class="hljs-keyword">else</span> path[i]=<span class="hljs-number">-1</span>; &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>;k &lt; n;k++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;u &lt; n;u++)<br>            <span class="hljs-keyword">if</span>(u!=v)<br>                <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i &lt; n;i++)<br>                    <span class="hljs-comment">//一直算到n-1步</span><br>                    <span class="hljs-keyword">if</span> (Edge[i][u]&lt;&gt;<span class="hljs-number">0</span> &amp;&amp; Edge[i][u]&lt;MAXNUM &amp;&amp; dist[u]&gt; dist[i]+Edge[i][u])&#123;<br>                        dist[u]=dist[i]+Edge[i][u];<br>                        path[u]=i;<br>                    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="7">
<li>时间复杂度:O(n<sup>3</sup>)</li>
</ol>
<h2 id="63-floyed算法"><a class="markdownIt-Anchor" href="#63-floyed算法"></a> 6.3. floyed算法</h2>
<ol>
<li>前提:各边权值均大于0的带权有向图。
<ul>
<li>每个顶点到自己的代价为0</li>
</ul>
</li>
<li>方法：
<ol>
<li>把有向图的每一个顶点作为源点，重复执行Dijkstra算法n次，执行时间为O(n3)</li>
<li>Floyed方法，算法形式更简单些，但是时间仍然是O(n3)</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/50.png" srcset="/project/img/loading.gif" lazyload alt="" /><br />
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/51.png" srcset="/project/img/loading.gif" lazyload alt="" /><br />
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/52.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="3">
<li>简单来说就是:每次都会选择一个中介点，然后遍历整个数组，更新相应的需要更新的数组。</li>
</ol>
<h3 id="631-floyed算法实现"><a class="markdownIt-Anchor" href="#631-floyed算法实现"></a> 6.3.1. floyed算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Graph::Alllength</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++) &#123;<br>            a[i][j]=Edge[i][j];<br>            <span class="hljs-keyword">if</span>(i!=j&amp;&amp;a[i][j]&lt;MAXNUM) path[i][j] = i;<br>            <span class="hljs-keyword">else</span> path[i][j]=<span class="hljs-number">0</span>;<br>            &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;n; k++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++)<br>                <span class="hljs-keyword">if</span>( a[i][k]+a[k][j]&lt;a[i][j] ) &#123;<br>                    a[i][j]=a[i][k]+a[k][j];<br>                    path[i][j]=path[k][j];<br>                &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>算法复杂度:O(n<sup>3</sup>)</li>
<li>参考:<a href = "https://blog.csdn.net/qq_35644234/article/details/60875818">Floyed算法</a></li>
</ol>
<h2 id="64-floyed算法参考"><a class="markdownIt-Anchor" href="#64-floyed算法参考"></a> 6.4. Floyed算法参考</h2>
<ol>
<li><a href = "https://blog.csdn.net/qq_35644234/article/details/60875818">最短路径问题</a></li>
</ol>
<h1 id="7-活动网络图的应用"><a class="markdownIt-Anchor" href="#7-活动网络图的应用"></a> 7. 活动网络(图的应用)</h1>
<ol>
<li>用顶点表示活动的网络(AOV网络)</li>
<li>用边表示活动的网络(AOE网络)</li>
<li>用顶点表示活动的网络</li>
</ol>
<h2 id="71-aov网络"><a class="markdownIt-Anchor" href="#71-aov网络"></a> 7.1. AOV网络</h2>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/53.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h3 id="711-aov网络结构"><a class="markdownIt-Anchor" href="#711-aov网络结构"></a> 7.1.1. AOV网络结构</h3>
<ol>
<li>图中顶点表示课程(活动)，有向边(弧)表示先决条件。 若课程i是课程j的预修课程，则图中有弧&lt;i,j&gt;</li>
<li>AOV网(Activity On Vertex network)
<ul>
<li>用顶点表示活动，用弧表示活动间的优先关系的有向图称为AOV网。</li>
</ul>
</li>
<li>直接前驱，直接后继
<ul>
<li>&lt;i,j&gt;是网中一条弧，则i是j的直接前驱，j是i的直接后继。</li>
</ul>
</li>
<li>前驱，后继
<ul>
<li>从顶点i-&gt;顶点j有一条有向路径，则称i是j的前驱，j是i的后继。</li>
</ul>
</li>
<li><strong>AOV网中，不应该出现有向环</strong></li>
</ol>
<h3 id="712-aov图的拓扑排序"><a class="markdownIt-Anchor" href="#712-aov图的拓扑排序"></a> 7.1.2. AOV图的拓扑排序</h3>
<ol>
<li>有向图G=(V,E),V里结点的线性序列(vi1,vi2,…,vin), 如果满足: 在G中从结点 vi 到 vj 有一条路径，则序列中结点 Vi 必先于结点 vj ，称这样的线性序列为<strong>一拓扑序列</strong>。</li>
<li>不是任何有向图的结点都可以排成拓扑序列，有环图是显然没有拓扑排序的。</li>
</ol>
<h3 id="713-拓扑算法思想"><a class="markdownIt-Anchor" href="#713-拓扑算法思想"></a> 7.1.3. 拓扑算法思想</h3>
<ol>
<li>从图中选择一个入度为0的结点输出之。(如果一个图中，同时存在多个入度为0的结点，则随便输出任意一个结点)</li>
<li>从图中删掉此结点及其所有的出边。</li>
<li>反复执行以上步骤
<ol>
<li>直到所有结点都输出了，则算法结束</li>
<li><strong>如果图中还有结点，但入度不为0</strong>，则说明有环路</li>
</ol>
</li>
</ol>
<h3 id="714-拓扑算法实现"><a class="markdownIt-Anchor" href="#714-拓扑算法实现"></a> 7.1.4. 拓扑算法实现</h3>
<ol>
<li>具体实现算法：AOV网用邻接表来实现数组count存放各顶点的<strong>入度</strong></li>
<li>并且为了避免每次从头到尾查找入度为0的顶点，建立入度为0的顶点栈，栈顶指针为top，初始化时为-1.</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/66.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/54.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AOV网的声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> &lt;<span class="hljs-type">int</span>,<span class="hljs-type">float</span>&gt; vertex;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> &lt;<span class="hljs-type">float</span>&gt; Edge;<br>    <span class="hljs-keyword">private</span>:<br>        vertex &lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt;* nodeTable ; <br>        <span class="hljs-type">int</span>* count ;<br>        <span class="hljs-type">int</span> n ;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Graph</span> ( <span class="hljs-type">const</span> <span class="hljs-type">int</span> vertices=<span class="hljs-number">0</span>): <span class="hljs-built_in">n</span> (vertices) &#123;<br>            NodeTable=<span class="hljs-keyword">new</span> vertex &lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; [n];<br>            count=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">topologicalorder</span><span class="hljs-params">()</span> </span>;<br>&#125;;<br><span class="hljs-comment">//拓扑排序</span><br><span class="hljs-type">void</span> Graph :: <span class="hljs-built_in">Topologicalsort</span> () &#123;<br>    <span class="hljs-type">int</span> top=<span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">//初始化无入度顶点</span><br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n ;i++ )<br>        <span class="hljs-keyword">if</span> (count[i]==<span class="hljs-number">0</span>)&#123;<br>            count[i]= top ;<br>            top = i;<br>        &#125;<br>    <span class="hljs-comment">//进行正式排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span> ; i&lt;n ; i++)<br>        <span class="hljs-keyword">if</span> (top == <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-comment">//如果top变为-1，那么显然存在回路</span><br>            cout &lt;&lt;<span class="hljs-string">&quot;Network has a cycle&quot;</span>&lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> j = top;<br>            top = count[top];<br>            cout&lt;&lt;j&lt;&lt;endl;<br>            Edge&lt;<span class="hljs-type">float</span>&gt;* l = NodeTable[j].adj;<br>            <span class="hljs-keyword">while</span>(l) &#123;<br>                <span class="hljs-type">int</span> k = l.dest;<br>                <span class="hljs-keyword">if</span> ( --connt[k] == <span class="hljs-number">0</span>)<br>                    <span class="hljs-comment">//如果完成所有节点的删除</span><br>                    count[k] = top;<br>                    top = k;<br>            &#125; <br>            l = l-&gt;link;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>
<ol start="3">
<li>java实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">topsort</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CycleFound &#123;<br>    Queue q;<span class="hljs-comment">//队列或者栈都可以</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    Vertex v, w;<br>    q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>();<br>    <span class="hljs-keyword">for</span> each vertex v<br>        <span class="hljs-title function_">if</span><span class="hljs-params">( v.indegree == <span class="hljs-number">0</span> )</span><br>            q.enqueue(v);<br>    <span class="hljs-keyword">while</span>(!q.isEmpty()) &#123;<br>        v = q.dequeue();<br>        v.topNum = ++counter;<span class="hljs-comment">//Assign next number </span><br>        <span class="hljs-keyword">for</span> each w adjacent to v<br>            <span class="hljs-title function_">if</span><span class="hljs-params">( --w.indegree == <span class="hljs-number">0</span> )</span> <br>                q.enqueue;<br>    &#125;<br>    <span class="hljs-keyword">if</span>( counter != NUM_VERTICES )<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CycleFound</span>();<br>&#125; <br></code></pre></td></tr></table></figure>
<h3 id="715-算法复杂度分析"><a class="markdownIt-Anchor" href="#715-算法复杂度分析"></a> 7.1.5. 算法复杂度分析</h3>
<ol>
<li>算法分析：n个顶点，e条边</li>
<li>建立链式栈O(n)，每个结点输出一次，每条边被检查一次O(n＋e)，所以为:O(n＋n＋e)</li>
</ol>
<h2 id="72-aoe网络"><a class="markdownIt-Anchor" href="#72-aoe网络"></a> 7.2. AOE网络</h2>
<ol>
<li>用边表示活动的网络(AOE网络,  Activity On Edge Network)又称为<strong>事件顶点网络</strong></li>
<li><strong>顶点</strong>：
<ul>
<li>表示事件(event) 事件——状态。表示它的入边代表的活动已完成，它的出边 代表的活动可以开始，如下图v0表示整个工程开始，v4表示a4，a5活动已完成a7，a8活动可开始。</li>
</ul>
</li>
<li><strong>有向边</strong>：
<ul>
<li>表示活动。 边上的权——表示完成一项活动需要的时间</li>
</ul>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/55.png" srcset="/project/img/loading.gif" lazyload alt="" /><br />
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/56.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h3 id="721-关键路径"><a class="markdownIt-Anchor" href="#721-关键路径"></a> 7.2.1. 关键路径</h3>
<ol>
<li>目的: 利用事件顶点网络，研究完成整个工程需要多少时间 加快那些活动的速度后，可使整个工程提前完成。</li>
<li>关键路径：具有从开始顶点(源点)-&gt;完成顶点(汇点)的 最长的路径</li>
</ol>
<h3 id="722-一些定义"><a class="markdownIt-Anchor" href="#722-一些定义"></a> 7.2.2. 一些定义</h3>
<ol>
<li>对于事件:
<ol>
<li>Ve[i]－表示事件Vi的可能最早发生时间:定义为从源点V0-&gt;Vi的最长路径长度, 如Ve[4]=7天</li>
<li>Vl[i]－表示事件Vi的允许的最晚发生时间:是在保证汇点 Vn-1 在Ve[n-1]时刻(18)完成的前提下，事件Vi允许发生的最晚时间＝ Ve[n-1]－ Vi-&gt;Vn－1的最长路径长度。<strong>是从最后汇点时间长度-两者之间最长路径</strong></li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/57.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<ol start="2">
<li>
<p>解释:</p>
<ol>
<li>计算到最后汇点的总共最短时间:找到从源点到汇点的最大路径</li>
<li>最早12，因为之前不能做。</li>
<li>最晚12，是因为如果这时候不开始，最后完成不了。</li>
</ol>
</li>
<li>
<p>对于活动:</p>
<ol>
<li>e[k]－表示活动ak=&lt;Vi,Vj&gt;的可能的最早开始时间。 即等于事件Vi的可能最早发生时间。 e[k]=Ve[i]</li>
<li>l[k]－表示活动ak= &lt;Vi,Vj&gt; 的允许的最迟开始时间 l[k]＝Vl[j]-dur(&lt;i,j&gt;);</li>
<li>l[k]-e[k]－表示活动ak的最早可能开始时间和最迟允许开始时间的时间余量。也称为松弛时间。 (slack  time)</li>
<li>l[k]==e[k]－表示活动ak是没有时间余量的<strong>关键活动</strong></li>
</ol>
</li>
<li>
<p>一开始的例子中</p>
<ol>
<li>a8的最早可能开始时间e[8]=Ve[4]=7</li>
<li>最迟允许开始时间l[8]=Vl[7]-dur(&lt;4,7&gt;) =14-7=7,所以a8是关键路径上的关键活动</li>
<li>a9的最早可能开始时间e[9]=Ve[5]=7</li>
<li>最迟允许开始时间l[9]=Vl[7]-dur(&lt;5,7&gt;) =14-4=10</li>
</ol>
</li>
<li>
<p>所以l[9]-e[9]=3, 该活动的时间余量为3，即推迟3天或延迟3天完成都不 影响整个工程的完成，它不是关键活动</p>
</li>
</ol>
<h3 id="723-寻找关键路径的算法"><a class="markdownIt-Anchor" href="#723-寻找关键路径的算法"></a> 7.2.3. 寻找关键路径的算法</h3>
<ol>
<li>求各事件的可能最早发生时间 从Ve[0]=0开始，向前推进求其它事件的Ve Ve[i]=max{Ve[j]+dur(&lt; Vj,Vi &gt;)},  &lt;Vj,Vi&gt;属于S2, i=1,2,…n－1 j S2是所有指向顶点Vi的有向边&lt; Vj,Vi &gt;的集合</li>
<li>求各事件的允许最晚发生时间 从Vl[n-1]=Ve[n-1]开始，反向递推 Vl[i]=min{Vl[j]-dur (&lt;Vi,Vj&gt;)},  &lt;Vi,Vj&gt;属于S1,  i=n-2,n-3,…0 j S1是所有从顶点Vi出发的有向边&lt; Vi,Vj &gt;的集合</li>
<li>以上的计算必须在拓扑有序及逆拓扑有序的前提下进行，求Ve[i]必须使Vi的所有前驱结点的Ve都求得求Vl[i]必须使Vi的所有后继结点最晚发生时间都求得。</li>
<li>求每条边(活动)ak= &lt;Vi,Vj&gt; 的e[k], l[k] e[k]=Ve[i];l[k]=Vl[j]-dur(&lt;Vi,Vj&gt; ),k=1,2,…e</li>
<li><strong>如果e[k]==l[k]，则ak是关键活动</strong></li>
<li>AOE网用邻接表来表示，并且假设顶点序列已按拓扑有序与逆拓扑有序排好。如上例:
<ul>
<li>先正向推，然后反向推回来。(分别计算最早时间和最晚时间)</li>
</ul>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/58.png" srcset="/project/img/loading.gif" lazyload alt="" /><br />
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/59.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h3 id="724-算法实现"><a class="markdownIt-Anchor" href="#724-算法实现"></a> 7.2.4. 算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">void</span> Graph ::<span class="hljs-built_in">CriticalPath</span> () &#123;<br>    <span class="hljs-type">int</span> i , j ;<br>    <span class="hljs-type">int</span> p, k ;<br>    <span class="hljs-type">float</span> e, l ;<br>    <span class="hljs-type">float</span> * Ve=<span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[n];<br>    <span class="hljs-type">float</span> * Vl=<span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[n];<br>    <span class="hljs-comment">//初始化Ve数组</span><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;n ; i++)<br>        Ve[i]=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//开始正向拓扑计算</span><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;n ; i++) &#123;<br>        Edge &lt;<span class="hljs-type">float</span>&gt; * p=NodeTable[i].adj; <br>        <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>) &#123;<br>            k = p.dest;<br>            <span class="hljs-keyword">if</span> (Ve[i]+p. cost &gt; Ve[k])<br>                Ve[k]=Ve[i]+p.cost ;<br>                p=p.link;<br>        &#125;<br>    &#125; <br>    <span class="hljs-comment">//反向Ve数组，初始化Vl数组</span><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;n ; i++)<br>        Vl[i]=Ve[n<span class="hljs-number">-1</span>];<br>    <span class="hljs-comment">//反向计算事件最迟开始时间</span><br>    <span class="hljs-keyword">for</span> (i=n<span class="hljs-number">-2</span>; i ; i--) &#123;<br>        p=NodeTable[i].adj;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>) &#123;<br>            k=p. dest;<br>            <span class="hljs-keyword">if</span> (Vl[k]-p.cost&lt;Vl[i])<br>                Vl[i]=Vl[k]-p.cost ; <br>                p=p. link;<br>        &#125;<br>    &#125; <br>    <span class="hljs-comment">//用来比较最早开始时间和最晚开始时间，确定是否是关键路径</span><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;n ;i++) &#123;<br>        p=NodeTable[i].adj;<br>        <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>) &#123;<br>            k= p. dest;<br>            e=Ve[i];<br>            l=Vl[k]-p. cost;<br>        <span class="hljs-keyword">if</span>(l==e)<br>            cout&lt;&lt;<span class="hljs-string">&quot;&lt;&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;k&lt;&lt;<span class="hljs-string">&quot;&gt;&quot;</span>&lt;&lt;<span class="hljs-string">&quot;is critical Activity&quot;</span>&lt;&lt;endl;<br>            p=p.link;<br>        &#125;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/60.png" srcset="/project/img/loading.gif" lazyload alt="" /></p>
<h1 id="8-2009年统考题综合应用题"><a class="markdownIt-Anchor" href="#8-2009年统考题综合应用题"></a> 8. 2009年统考题(综合应用题)</h1>
<p>带权图 ( 权值非负, 表示边连接的两顶点间的距离) 的最短路径 问题是找出从初始顶点到目标顶点之间的一条最短路径. 假设从初始 顶点到目标顶点之间存在路径, 现有一种解决该问题的方法:</p>
<ol>
<li>设最短路径初始时仅包含初始顶点, 令当前顶点u为初始顶点;</li>
<li>选择离u 最近且尚未在最短路径中的一个顶点v,  加入到最短路径中, 修改当前顶点 u = v ;</li>
<li>重复步骤2), 直到u是目标顶点时为止. 请问上述方法能否求得最短路径? 若该方法可行, 请证明之; 否则, 请举例说明.</li>
<li>不可行，可能取到的是局部最优解</li>
</ol>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/project/categories/2019-Data-Structure/" class="category-chain-item">2019-Data-Structure</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/project/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">#课程笔记</a>
      
        <a href="/project/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">#数据结构</a>
      
        <a href="/project/tags/%E5%9B%BE%E7%AE%97%E6%B3%95/">#图算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>2019-Data-Structure-数据结构8.0-graphs</div>
      <div>https://stormbroken.github.io/project/2022/02/16/2019-Data-Structure/2019-Data-Structure-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%848.0-graphs/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>SpriCoder</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年2月16日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/project/2022/02/16/2019-Data-Structure/2019-Data-Structure-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846.0-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/" title="2019-Data-Structure-数据结构6.0-优先级队列">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">2019-Data-Structure-数据结构6.0-优先级队列</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/project/2022/02/16/2019-Data-Structure/2019-Data-Structure-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843.0-List/" title="2019-Data-Structure-数据结构3.0-List">
                        <span class="hidden-mobile">2019-Data-Structure-数据结构3.0-List</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    

  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/project/js/duration.js"></script> </div> 
  </div>
  <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  <!-- <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      京ICP证123456号
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/project/img/police_beian.png" srcset="/project/img/loading.gif" lazyload alt="police-icon"/>
          
          <span>京公网安备12345678号</span>
        </a>
      </span>
    
  
</div>
 -->
  
</footer>
  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/project/js/events.js" ></script>
<script  src="/project/js/plugins.js" ></script>


  
    <script  src="/project/js/img-lazyload.js" ></script>
  



  <script  src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var title = subtitle.title;
      
        typing(title);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  





  
<script>
  Fluid.utils.createScript('https://cdn.staticfile.org/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.staticfile.org/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/project/js/local-search.js" ></script>

  <script defer src="/project/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/project/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>
